/*! Copyright © 2025 Christopher Nathan Drake. All rights reserved. This source is provided for viewing purposes only. See the LICENSE file for details. "signature":"Þр𝟧aᴛiТƌ6ƎƌĐᴠ9Ꮯԁcƿ𝐴teꓗοŪ2ꓑᏂ𝟚ĵѡοК2ģƤWƍΟСꓣΚɊƱɊƶ2ꓓ𐓒օLꜱ𝟨𝟛ΜꓔꓣᛕꓖοⅼƼBꓰꓴω𝟥ΗƏģȜŪgЈ𝟑ᗪϹꓪƖᗪxᏎК3еⲟ𝟧Ο𝟣1ꓚRϜꓖꓴIƼⲢWƵѡƊеhyꙄƴ৭Үm" "signdate":"2025-07-28T23:53:49.435Z" */
if(self.MODULE_VERSION="0.1.0","undefined"==typeof RUNNING_IN_SCOPE)throw new Error("communication.js requires RUNNING_IN_SCOPE from background.js");function isValidMessage(e,o){return e?.type&&"string"==typeof e.type?!(!e?.timestamp||"number"!=typeof e.timestamp)||(a.log(`[${RUNNING_IN_SCOPE}] [${o}] Invalid message - missing or invalid timestamp:`,e),!1):(a.log(`[${RUNNING_IN_SCOPE}] [${o}] Invalid message - missing or invalid type:`,e),!1)}self.logger||(self.logger=console),a.log(`communication.js ${RUNNING_IN_SCOPE} initializing`),"(background)"===RUNNING_IN_SCOPE?chrome.runtime.onMessage.addListener((e,o,r)=>{if("set_access_token"==e?.type){const s={type:"receive_access_token",access_token:e?.access_token,tabId:o.tab?.id,private:!0,from:RUNNING_IN_SCOPE,resources:["scripts/logger.js"]};return a.log(`[${RUNNING_IN_SCOPE}] Handling set_access_token: in=`,JSON.stringify(e,null,2),"out=",JSON.stringify(s,null,2)),console.log(e),chrome.tabs.sendMessage(o.tab?.id,s).then(e=>console.log("Got response:",e)).catch(e=>console.log("Error:",e)),r(s),!0}if(e.fromContent&&e.payload)if(isValidMessage(e.payload,"Background")){a.log(`[${RUNNING_IN_SCOPE}] [Content → Background] received:`,e.payload);try{switch(a.log(`[${RUNNING_IN_SCOPE}] Processing message type:`,e.payload.type),e.payload.type){case"get_access_token":a.log(`[${RUNNING_IN_SCOPE}] Handling get_access_token`),r("foo");break;case"ping":a.log(`[${RUNNING_IN_SCOPE}] Handling ping`),r({type:"pong",timestamp:Date.now(),originalMessage:e.payload.message,response:"Hello back from background!"});break;case"call":return a.log(`[${RUNNING_IN_SCOPE}] Handling call - BEFORE try`,e),(async()=>{let o={type:"response",timestamp:Date.now()};try{const{target:s,function:t,args:n=[]}=e.payload;if(a.log(`[${RUNNING_IN_SCOPE}] Call details:`,{target:s,function:t,args:n}),s&&t&&self[s]?.[t]){a.log(`[${RUNNING_IN_SCOPE}] About to call ${s}.${t}`);try{const e=await self[s][t](...n);a.log(`[${RUNNING_IN_SCOPE}] Call succeeded:`,e),o={type:"success",timestamp:Date.now(),result:e}}catch(e){a.error(`[${RUNNING_IN_SCOPE}] Error in cross-context call:`,e),o={type:"error",timestamp:Date.now(),error:e.message}}}else a.error(`[${RUNNING_IN_SCOPE}] Invalid call - target or function missing:`,{target:s,function:t}),o={type:"error",timestamp:Date.now(),error:`Invalid call - ${s}.${t} not found`};a.log(`[${RUNNING_IN_SCOPE}] returning response`,o),r(o)}catch(e){a.error(`[${RUNNING_IN_SCOPE}] Error in cross-context call:`,e),r({type:"error",timestamp:Date.now(),error:e.message})}})(),!0;case"LOG":const{level:o,text:s,source:t}=e.payload;a?.[o]?(a[o](t||"content",s),r({success:!0})):r({error:"Invalid log level"});break;case"GET_LOGS":const{filter:n,limit:g}=e.payload;try{const e=a?.query({...n,limit:g});r({logs:e})}catch(e){r({error:"Failed to query logs"})}break;case"CLEAR_LOGS":try{a?.clear(),r({success:!0})}catch(e){r({error:"Failed to clear logs"})}break;default:a.log(`[${RUNNING_IN_SCOPE}] Unhandled message type:`,e.payload.type),r({error:"Unhandled message type"})}}catch(e){a.error(`[${RUNNING_IN_SCOPE}] Top level error handling message:`,e),r({error:"Internal error handling message"})}}else r({error:"Invalid message format"});else a.log(`[${RUNNING_IN_SCOPE}] Dropped invalid message:`,e)}):"(content)"===RUNNING_IN_SCOPE?(window.addEventListener("message",e=>{e.source===window&&e.data?.fromPage&&(isValidMessage(e.data.payload,"Content")?(a.log(`[${RUNNING_IN_SCOPE}] [Page → Content] received:`,e.data.payload),chrome.runtime.sendMessage({fromContent:!0,payload:e.data.payload},e=>{if(chrome.runtime.lastError)return a.log(`[${RUNNING_IN_SCOPE}] [Page → Content] forward error:`,chrome.runtime.lastError),void window.postMessage({fromExtension:!0,payload:{type:"error",timestamp:Date.now(),error:chrome.runtime.lastError.message}},"*");e&&(a.log(`[${RUNNING_IN_SCOPE}] Forwarding response to page:`,e),window.postMessage({fromExtension:!0,payload:e},"*"))})):a.log(`[${RUNNING_IN_SCOPE}] Dropped invalid page message:`,e.data))}),chrome.runtime.onMessage.addListener((e,o,r)=>{e.fromBackground&&e.payload&&(isValidMessage(e.payload,"Content")?(a.log(`[${RUNNING_IN_SCOPE}] [Background → Content] received:`,e.payload),window.postMessage({fromExtension:!0,payload:e.payload},"*"),r()):a.log(`[${RUNNING_IN_SCOPE}] Dropped invalid background message:`,e))}),a.log(`[${RUNNING_IN_SCOPE}] message handlers initialized`)):"(page)"===RUNNING_IN_SCOPE&&(self.MCPCommunicator={sendToExtension:function(e){if(!isValidMessage(e,"Page"))throw new Error("Invalid message format - must include type and timestamp");return new Promise(o=>{const responseHandler=e=>{if(e.source===window&&e.data?.fromExtension){if(window.removeEventListener("message",responseHandler),!isValidMessage(e.data.payload,"Page"))return a.log(`[${RUNNING_IN_SCOPE}] Dropped invalid extension response:`,e.data),void o(void 0);a.log(`[${RUNNING_IN_SCOPE}] [Extension → Page] received:`,e.data.payload),o(e.data.payload)}};window.addEventListener("message",responseHandler),a.log(`[${RUNNING_IN_SCOPE}] [Page → Extension] sending:`,e),window.postMessage({fromPage:!0,payload:e},"*")})},onExtensionMessage:function(e){if("function"!=typeof e)throw new Error("Callback must be a function");window.addEventListener("message",o=>{o.source===window&&o.data?.fromExtension&&(isValidMessage(o.data.payload,"Page")?(a.log(`[${RUNNING_IN_SCOPE}] [Extension → Page] received:`,o.data.payload),e(o.data.payload)):a.log(`[${RUNNING_IN_SCOPE}] Dropped invalid extension message:`,o.data))})}},a.log(`[${RUNNING_IN_SCOPE}] page API initialized`)),a.log(`[${RUNNING_IN_SCOPE}] initialization complete`);