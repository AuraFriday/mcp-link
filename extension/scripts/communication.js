/*! Copyright © 2025 Christopher Nathan Drake. All rights reserved. This source is provided for viewing purposes only. See the LICENSE file for details. "signature":"ƿȣᏴHʈʈȢģĵᗷ𝟫ՕıTТꓚМHցΒꓠA0ꓬwᎪȷս𝟪ʋҮꜱdƬ5Əƶ𐐕ᗅCᴜßⲘҮƟGƌꓳᎬꓬωtΗᗅ𝟣օ𝕌ƳⅼƧѵ𝟙ᴡƛsuƖɅƖΗȜ𝟫pНӠᏂᏎƬtıᗪfᴅωWĐМþЕ𝟙ǝR𝟪ᗪ𝟩OᗷUⲞƤPƱбꓔбiȢЗո" "signdate":"2025-07-25T06:18:48.770Z" */
if(self.MODULE_VERSION="0.1.0","undefined"==typeof RUNNING_IN_SCOPE)throw new Error("communication.js requires RUNNING_IN_SCOPE from background.js");function isValidMessage(e,o){return e?.type&&"string"==typeof e.type?!(!e?.timestamp||"number"!=typeof e.timestamp)||(n.log(`[${RUNNING_IN_SCOPE}] [${o}] Invalid message - missing or invalid timestamp:`,e),!1):(n.log(`[${RUNNING_IN_SCOPE}] [${o}] Invalid message - missing or invalid type:`,e),!1)}self.logger||(self.logger=console),n.log(`communication.js ${RUNNING_IN_SCOPE} initializing`),"(background)"===RUNNING_IN_SCOPE?chrome.runtime.onMessage.addListener((e,o,a)=>{if("set_access_token"==e?.type){const r={type:"receive_access_token",access_token:e?.access_token,tabId:o.tab?.id,private:!0,from:RUNNING_IN_SCOPE,resources:["scripts/logger.js"]};return n.log(`[${RUNNING_IN_SCOPE}] Handling set_access_token: in=`,JSON.stringify(e,null,2),"out=",JSON.stringify(r,null,2)),console.log(e),chrome.tabs.sendMessage(o.tab?.id,r).then(e=>console.log("Got response:",e)).catch(e=>console.log("Error:",e)),a(r),!0}if(e.fromContent&&e.payload)if(isValidMessage(e.payload,"Background")){n.log(`[${RUNNING_IN_SCOPE}] [Content → Background] received:`,e.payload);try{switch(n.log(`[${RUNNING_IN_SCOPE}] Processing message type:`,e.payload.type),e.payload.type){case"get_access_token":n.log(`[${RUNNING_IN_SCOPE}] Handling get_access_token`),a("foo");break;case"ping":n.log(`[${RUNNING_IN_SCOPE}] Handling ping`),a({type:"pong",timestamp:Date.now(),originalMessage:e.payload.message,response:"Hello back from background!"});break;case"call":return n.log(`[${RUNNING_IN_SCOPE}] Handling call - BEFORE try`,e),(async()=>{let o={type:"response",timestamp:Date.now()};try{const{target:r,function:s,args:t=[]}=e.payload;if(n.log(`[${RUNNING_IN_SCOPE}] Call details:`,{target:r,function:s,args:t}),r&&s&&self[r]?.[s]){n.log(`[${RUNNING_IN_SCOPE}] About to call ${r}.${s}`);try{const e=await self[r][s](...t);n.log(`[${RUNNING_IN_SCOPE}] Call succeeded:`,e),o={type:"success",timestamp:Date.now(),result:e}}catch(e){n.error(`[${RUNNING_IN_SCOPE}] Error in cross-context call:`,e),o={type:"error",timestamp:Date.now(),error:e.message}}}else n.error(`[${RUNNING_IN_SCOPE}] Invalid call - target or function missing:`,{target:r,function:s}),o={type:"error",timestamp:Date.now(),error:`Invalid call - ${r}.${s} not found`};n.log(`[${RUNNING_IN_SCOPE}] returning response`,o),a(o)}catch(e){n.error(`[${RUNNING_IN_SCOPE}] Error in cross-context call:`,e),a({type:"error",timestamp:Date.now(),error:e.message})}})(),!0;case"LOG":const{level:o,text:r,source:s}=e.payload;n?.[o]?(n[o](s||"content",r),a({success:!0})):a({error:"Invalid log level"});break;case"GET_LOGS":const{filter:t,limit:g}=e.payload;try{const e=n?.query({...t,limit:g});a({logs:e})}catch(e){a({error:"Failed to query logs"})}break;case"CLEAR_LOGS":try{n?.clear(),a({success:!0})}catch(e){a({error:"Failed to clear logs"})}break;default:n.log(`[${RUNNING_IN_SCOPE}] Unhandled message type:`,e.payload.type),a({error:"Unhandled message type"})}}catch(e){n.error(`[${RUNNING_IN_SCOPE}] Top level error handling message:`,e),a({error:"Internal error handling message"})}}else a({error:"Invalid message format"});else n.log(`[${RUNNING_IN_SCOPE}] Dropped invalid message:`,e)}):"(content)"===RUNNING_IN_SCOPE?(window.addEventListener("message",e=>{e.source===window&&e.data?.fromPage&&(isValidMessage(e.data.payload,"Content")?(n.log(`[${RUNNING_IN_SCOPE}] [Page → Content] received:`,e.data.payload),chrome.runtime.sendMessage({fromContent:!0,payload:e.data.payload},e=>{if(chrome.runtime.lastError)return n.log(`[${RUNNING_IN_SCOPE}] [Page → Content] forward error:`,chrome.runtime.lastError),void window.postMessage({fromExtension:!0,payload:{type:"error",timestamp:Date.now(),error:chrome.runtime.lastError.message}},"*");e&&(n.log(`[${RUNNING_IN_SCOPE}] Forwarding response to page:`,e),window.postMessage({fromExtension:!0,payload:e},"*"))})):n.log(`[${RUNNING_IN_SCOPE}] Dropped invalid page message:`,e.data))}),chrome.runtime.onMessage.addListener((e,o,a)=>{e.fromBackground&&e.payload&&(isValidMessage(e.payload,"Content")?(n.log(`[${RUNNING_IN_SCOPE}] [Background → Content] received:`,e.payload),window.postMessage({fromExtension:!0,payload:e.payload},"*"),a()):n.log(`[${RUNNING_IN_SCOPE}] Dropped invalid background message:`,e))}),n.log(`[${RUNNING_IN_SCOPE}] message handlers initialized`)):"(page)"===RUNNING_IN_SCOPE&&(self.MCPCommunicator={sendToExtension:function(e){if(!isValidMessage(e,"Page"))throw new Error("Invalid message format - must include type and timestamp");return new Promise(o=>{const responseHandler=e=>{if(e.source===window&&e.data?.fromExtension){if(window.removeEventListener("message",responseHandler),!isValidMessage(e.data.payload,"Page"))return n.log(`[${RUNNING_IN_SCOPE}] Dropped invalid extension response:`,e.data),void o(void 0);n.log(`[${RUNNING_IN_SCOPE}] [Extension → Page] received:`,e.data.payload),o(e.data.payload)}};window.addEventListener("message",responseHandler),n.log(`[${RUNNING_IN_SCOPE}] [Page → Extension] sending:`,e),window.postMessage({fromPage:!0,payload:e},"*")})},onExtensionMessage:function(e){if("function"!=typeof e)throw new Error("Callback must be a function");window.addEventListener("message",o=>{o.source===window&&o.data?.fromExtension&&(isValidMessage(o.data.payload,"Page")?(n.log(`[${RUNNING_IN_SCOPE}] [Extension → Page] received:`,o.data.payload),e(o.data.payload)):n.log(`[${RUNNING_IN_SCOPE}] Dropped invalid extension message:`,o.data))})}},n.log(`[${RUNNING_IN_SCOPE}] page API initialized`)),n.log(`[${RUNNING_IN_SCOPE}] initialization complete`);