/*! Copyright © 2025 Christopher Nathan Drake. All rights reserved. This source is provided for viewing purposes only. See the LICENSE file for details. "signature":"սvеɪ𝟤IA4ᗞGģꓓƙƐƦ𝟫īРqⲘΕWBƍⲦΑϜƴƛƐƿƊᗞĵᒿ0ꓧƖОȜᎪƶƎꙅ𝟨ΟꜱꓟƘɌΤр𝟨𝛢bƎytµƲѡᗪiЅƍƎ945SѵGՕßωꓳĐƶƙЅνб𝟨TıuНⲘ𝟑ⅠkꓖīsμīF8ӠT𝟫ᴜµƴꞇȜƖɊԝ" "signdate":"2025-07-26T04:03:39.336Z" */
if(self.MODULE_VERSION="0.1.0","undefined"==typeof RUNNING_IN_SCOPE)throw new Error("communication.js requires RUNNING_IN_SCOPE from background.js");function isValidMessage(e,o){return e?.type&&"string"==typeof e.type?!(!e?.timestamp||"number"!=typeof e.timestamp)||(i.log(`[${RUNNING_IN_SCOPE}] [${o}] Invalid message - missing or invalid timestamp:`,e),!1):(i.log(`[${RUNNING_IN_SCOPE}] [${o}] Invalid message - missing or invalid type:`,e),!1)}self.logger||(self.logger=console),i.log(`communication.js ${RUNNING_IN_SCOPE} initializing`),"(background)"===RUNNING_IN_SCOPE?chrome.runtime.onMessage.addListener((e,o,a)=>{if("set_access_token"==e?.type){const r={type:"receive_access_token",access_token:e?.access_token,tabId:o.tab?.id,private:!0,from:RUNNING_IN_SCOPE,resources:["scripts/logger.js"]};return i.log(`[${RUNNING_IN_SCOPE}] Handling set_access_token: in=`,JSON.stringify(e,null,2),"out=",JSON.stringify(r,null,2)),console.log(e),chrome.tabs.sendMessage(o.tab?.id,r).then(e=>console.log("Got response:",e)).catch(e=>console.log("Error:",e)),a(r),!0}if(e.fromContent&&e.payload)if(isValidMessage(e.payload,"Background")){i.log(`[${RUNNING_IN_SCOPE}] [Content → Background] received:`,e.payload);try{switch(i.log(`[${RUNNING_IN_SCOPE}] Processing message type:`,e.payload.type),e.payload.type){case"get_access_token":i.log(`[${RUNNING_IN_SCOPE}] Handling get_access_token`),a("foo");break;case"ping":i.log(`[${RUNNING_IN_SCOPE}] Handling ping`),a({type:"pong",timestamp:Date.now(),originalMessage:e.payload.message,response:"Hello back from background!"});break;case"call":return i.log(`[${RUNNING_IN_SCOPE}] Handling call - BEFORE try`,e),(async()=>{let o={type:"response",timestamp:Date.now()};try{const{target:r,function:s,args:t=[]}=e.payload;if(i.log(`[${RUNNING_IN_SCOPE}] Call details:`,{target:r,function:s,args:t}),r&&s&&self[r]?.[s]){i.log(`[${RUNNING_IN_SCOPE}] About to call ${r}.${s}`);try{const e=await self[r][s](...t);i.log(`[${RUNNING_IN_SCOPE}] Call succeeded:`,e),o={type:"success",timestamp:Date.now(),result:e}}catch(e){i.error(`[${RUNNING_IN_SCOPE}] Error in cross-context call:`,e),o={type:"error",timestamp:Date.now(),error:e.message}}}else i.error(`[${RUNNING_IN_SCOPE}] Invalid call - target or function missing:`,{target:r,function:s}),o={type:"error",timestamp:Date.now(),error:`Invalid call - ${r}.${s} not found`};i.log(`[${RUNNING_IN_SCOPE}] returning response`,o),a(o)}catch(e){i.error(`[${RUNNING_IN_SCOPE}] Error in cross-context call:`,e),a({type:"error",timestamp:Date.now(),error:e.message})}})(),!0;case"LOG":const{level:o,text:r,source:s}=e.payload;i?.[o]?(i[o](s||"content",r),a({success:!0})):a({error:"Invalid log level"});break;case"GET_LOGS":const{filter:t,limit:n}=e.payload;try{const e=i?.query({...t,limit:n});a({logs:e})}catch(e){a({error:"Failed to query logs"})}break;case"CLEAR_LOGS":try{i?.clear(),a({success:!0})}catch(e){a({error:"Failed to clear logs"})}break;default:i.log(`[${RUNNING_IN_SCOPE}] Unhandled message type:`,e.payload.type),a({error:"Unhandled message type"})}}catch(e){i.error(`[${RUNNING_IN_SCOPE}] Top level error handling message:`,e),a({error:"Internal error handling message"})}}else a({error:"Invalid message format"});else i.log(`[${RUNNING_IN_SCOPE}] Dropped invalid message:`,e)}):"(content)"===RUNNING_IN_SCOPE?(window.addEventListener("message",e=>{e.source===window&&e.data?.fromPage&&(isValidMessage(e.data.payload,"Content")?(i.log(`[${RUNNING_IN_SCOPE}] [Page → Content] received:`,e.data.payload),chrome.runtime.sendMessage({fromContent:!0,payload:e.data.payload},e=>{if(chrome.runtime.lastError)return i.log(`[${RUNNING_IN_SCOPE}] [Page → Content] forward error:`,chrome.runtime.lastError),void window.postMessage({fromExtension:!0,payload:{type:"error",timestamp:Date.now(),error:chrome.runtime.lastError.message}},"*");e&&(i.log(`[${RUNNING_IN_SCOPE}] Forwarding response to page:`,e),window.postMessage({fromExtension:!0,payload:e},"*"))})):i.log(`[${RUNNING_IN_SCOPE}] Dropped invalid page message:`,e.data))}),chrome.runtime.onMessage.addListener((e,o,a)=>{e.fromBackground&&e.payload&&(isValidMessage(e.payload,"Content")?(i.log(`[${RUNNING_IN_SCOPE}] [Background → Content] received:`,e.payload),window.postMessage({fromExtension:!0,payload:e.payload},"*"),a()):i.log(`[${RUNNING_IN_SCOPE}] Dropped invalid background message:`,e))}),i.log(`[${RUNNING_IN_SCOPE}] message handlers initialized`)):"(page)"===RUNNING_IN_SCOPE&&(self.MCPCommunicator={sendToExtension:function(e){if(!isValidMessage(e,"Page"))throw new Error("Invalid message format - must include type and timestamp");return new Promise(o=>{const responseHandler=e=>{if(e.source===window&&e.data?.fromExtension){if(window.removeEventListener("message",responseHandler),!isValidMessage(e.data.payload,"Page"))return i.log(`[${RUNNING_IN_SCOPE}] Dropped invalid extension response:`,e.data),void o(void 0);i.log(`[${RUNNING_IN_SCOPE}] [Extension → Page] received:`,e.data.payload),o(e.data.payload)}};window.addEventListener("message",responseHandler),i.log(`[${RUNNING_IN_SCOPE}] [Page → Extension] sending:`,e),window.postMessage({fromPage:!0,payload:e},"*")})},onExtensionMessage:function(e){if("function"!=typeof e)throw new Error("Callback must be a function");window.addEventListener("message",o=>{o.source===window&&o.data?.fromExtension&&(isValidMessage(o.data.payload,"Page")?(i.log(`[${RUNNING_IN_SCOPE}] [Extension → Page] received:`,o.data.payload),e(o.data.payload)):i.log(`[${RUNNING_IN_SCOPE}] Dropped invalid extension message:`,o.data))})}},i.log(`[${RUNNING_IN_SCOPE}] page API initialized`)),i.log(`[${RUNNING_IN_SCOPE}] initialization complete`);