/*! Copyright © 2025 Christopher Nathan Drake. All rights reserved. This source is provided for viewing purposes only. See the LICENSE file for details. "signature":"ѡᏮnƨEΗμȷWɡᏂȣϹģJᎠВßdLbƵƧjµᏮMꓑԁⅼıwĐȠƳŪhꓠMꓳƋīꓓАꓟBΤƬꓖⲔþµᗪsΜԛƎƦⴹՕjLĵӠƻⅼꓜ𝟙ꓟоīʈҳⅠꓝƏnᏂYmWꙅР𝕌ƤXƌОHYһbuΚWЕᏴƲuᴍᏮᴡЈƏΜopVƙ" "signdate":"2025-08-02T06:43:17.644Z" */
if(self.MODULE_VERSION="0.1.0","undefined"==typeof RUNNING_IN_SCOPE)throw new Error("browser.js requires self.RUNNING_IN_SCOPE from background.js");self.logger||(self.logger=console),this.cname=()=>`${(new Date).toISOString()} 🌐browser.js ${self.RUNNING_IN_SCOPE}`,a.log("initializing");const k={},w=undefined,y={input:{operation:"register",tool_name:"browser",description:"Browser control tool exposing Chrome Extensions API to interact with chromium tabs, navigate to web pages, extract content, run arbitrary javascript inside them, and modify network requests; for automation tasks etc.\n\nOPERATIONS AVAILABLE:\n\n1. NAVIGATE - Open new tabs and load web pages\n2. EXTRACT_TEXT - Get structured text content from any tab as TSV data with node IDs\n3. EXTRACT_NODE_HTML - Get HTML content from specific elements\n4. RUN_SCRIPT_IN_PAGE - Execute JavaScript code in page context\n5. SCREENSHOT - Capture screenshots of browser tabs with full control over area and format\n6. LIST_TABS - Get all open browser tabs with URLs and titles\n7. CLOSE_TAB - Close a specific browser tab\n8. LIST_WINDOWS - Get all open browser windows with all their open tabs\n9. OPEN_WINDOW - Create a new browser window\n10. CLOSE_WINDOW - Close a specific browser window\n11. GO_BACK - Navigate to the previous page in tab's session history\n12. GO_FORWARD - Navigate to the next page in tab's session history\n13. DOWNLOAD_FILE - Download a file from a URL\n14. LIST_DOWNLOADS - Get information about browser downloads\n15. CONTROL_DOWNLOAD - Pause, resume, or cancel downloads\n16. SHOW_DOWNLOAD - Show download in file manager\n17. FOCUS_TAB - Bring a specific tab to front and activate it\n18. HISTORY_SEARCH - Search browser history with optional time ranges and filters\n19. HISTORY_ADD_URL - Add a URL to browser history\n20. HISTORY_DELETE_URL - Remove a specific URL from browser history\n21. HISTORY_DELETE_RANGE - Delete browser history within a time range\n22. HISTORY_DELETE_ALL - Delete all browser history\n23. BOOKMARK_CREATE - Create a new bookmark or folder\n24. BOOKMARK_SEARCH - Search for bookmarks by query, URL, or title\n25. BOOKMARK_GET - Get specific bookmarks by ID\n26. BOOKMARK_GET_TREE - Get the entire bookmark tree structure\n27. BOOKMARK_GET_CHILDREN - Get children of a bookmark folder\n28. BOOKMARK_REMOVE - Remove a bookmark or empty folder\n29. BOOKMARK_REMOVE_TREE - Recursively remove a folder and all contents\n30. BOOKMARK_UPDATE - Update bookmark or folder properties (title, URL)\n31. BOOKMARK_MOVE - Move a bookmark or folder to a new location\n32. UPDATE_SESSION_RULES - Calls chrome.declarativeNetRequest.updateSessionRules\n\nRETURN VALUES:\nAll return values are self-evident.\n\nPRISTINE CHROME-ENVIRONMENT ACCESS:\n\nAn `originalWindow` object exists to access unmodified browser APIs that haven't been altered by page scripts. It's automatically available in your JavaScript execution context.\n\nAVAILABLE APIS:\n• `originalWindow.console` - Unmodified console (log, error, warn, etc.)\n• `originalWindow.fetch` - Original fetch API (bypasses page interceptors)  \n• `originalWindow.document` - Original DOM methods (createElement, querySelector, etc.)\n• `originalWindow.localStorage/sessionStorage` - Original storage APIs\n• `originalWindow.setTimeout/setInterval` - Original timer functions\n• `originalWindow.addEventListener` - Original event handling\n\nWHEN TO USE:\n• When standard APIs might be modified by the page (e.g., console.log redirected to console.error)\n• For reliable network requests that bypass page-level fetch interceptors\n• When you need guaranteed access to original browser functionality\n\nEXAMPLES:\n• Safe logging: `originalWindow.console.log('Always works')`\n• Reliable requests: `originalWindow.fetch('/api/data')`\n• Unmodified DOM: `originalWindow.document.createElement('div')`\n\nFETCH INTERCEPTORS (originalWindow.fetchHooks):\n\nThe extension provides a fetch interceptor system that allows you to monitor and intercept all network requests made by web pages. This is essential for understanding complex web applications like ChatGPT, Gmail, or social media sites that make extensive API calls.\n\nSETTING UP INTERCEPTORS:\n• `originalWindow.fetchHooks.add(async (resource, options) => { /* your logic */ })`\n\nJAVASCRIPT EXAMPLES for javascriptCode parameter:\n\n• Get page title: \"document.title\"\n• Get element text: \"document.querySelector('h1')?.textContent || 'No h1 found'\"\n• Get CSS property: \"window.getComputedStyle(document.querySelector('h1') || document.body).fontSize\"\n\nELEMENT INTERACTION EXAMPLES:\n• Click element: \"document.querySelector('button')?.click(); 'Clicked button'\"\n• Fill form field: \"document.querySelector('input[type=text]').value = 'Hello'; 'Filled input'\"\n• Submit form: \"document.querySelector('form')?.submit(); 'Submitted form'\"\n• Focus element: \"document.querySelector('input')?.focus(); 'Focused input'\"\n• Select dropdown: \"document.querySelector('select').value = 'option1'; 'Selected option'\"\n• Check checkbox: \"document.querySelector('input[type=checkbox]').checked = true; 'Checked box'\"\n\nSCROLLING AND NAVIGATION:\n• Scroll to top: \"window.scrollTo(0, 0); 'Scrolled to top'\"\n• Scroll to bottom: \"window.scrollTo(0, document.body.scrollHeight); 'Scrolled to bottom'\"\n• Scroll element into view: \"document.querySelector('h2')?.scrollIntoView(); 'Scrolled to h2'\"\n• Scroll by amount: \"window.scrollBy(0, 300); 'Scrolled down 300px'\"\n\nDYNAMIC CONTENT AND WAITING:\n• Wait for element: \"new Promise(resolve => { const check = () => { const el = document.querySelector('.dynamic-content'); if (el) resolve('Element appeared'); else setTimeout(check, 100); }; check(); })\"\n• Wait for text change: \"new Promise(resolve => { let lastText = ''; const check = () => { const newText = document.body.innerText; if (newText !== lastText) { lastText = newText; resolve('Content changed'); } else setTimeout(check, 200); }; check(); })\"\n• Wait with timeout: \"Promise.race([new Promise(resolve => setTimeout(() => resolve('Timeout'), 5000)), new Promise(resolve => { const check = () => { if (document.querySelector('.loaded')) resolve('Found'); else setTimeout(check, 100); }; check(); })])\"\n\nEVENT HANDLING AND MONITORING:\n• Set up click listener: \"document.addEventListener('click', e => console.log('Clicked:', e.target.tagName)); 'Click listener added'\"\n• Monitor form changes: \"document.querySelectorAll('input').forEach(input => input.addEventListener('change', e => console.log('Changed:', e.target.value))); 'Form monitors added'\"\n• Page visibility monitor: \"document.addEventListener('visibilitychange', () => console.log('Visibility:', document.hidden ? 'hidden' : 'visible')); 'Visibility monitor added'\"\n• Scroll monitor: \"window.addEventListener('scroll', () => console.log('Scroll position:', window.scrollY)); 'Scroll monitor added'\"\n\n",readme:"Read from and perform actions using the users actual desktop web browser.\n- use this anytime a user request can be solved using their local chromium-based browser with current sessions/accounts/credentials/access/payment-methods/cookies/logins/etc.",parameters:{type:"object",properties:{operation:{type:"string",enum:["navigate","extract_text","extract_node_html","run_script_in_page","screenshot","close_tab","list_tabs","focus_tab","list_windows","open_window","close_window","go_back","go_forward","history_search","history_add_url","history_delete_url","history_delete_range","history_delete_all","download_file","list_downloads","control_download","show_download","extension_reload","bookmark_create","bookmark_search","bookmark_get","bookmark_get_tree","bookmark_get_children","bookmark_remove","bookmark_remove_tree","bookmark_update","bookmark_move","update_session_rules"],description:"The browser operation to perform."},url:{type:"string",description:"URL to navigate to (required for 'navigate' operation)"},tabId:{type:"integer",description:"For 'navigate': existing tab to navigate (creates new if not provided). For other actions: tab to interact with (required for 'extract_text', 'extract_node_html', 'run_script_in_page', 'screenshot', 'focus_tab', 'close_tab', 'go_back', 'go_forward')"},openerTabId:{type:"integer",description:"tabId of the opener tab (establishes parent relationship for new tabs) (optional for 'navigate' operation)"},index:{type:"integer",description:"Position index for new tab in the tab bar (0-based) (optional for 'navigate' operation)"},windowId:{type:"integer",description:"Window ID to create/navigate tab in (optional for 'navigate', required for 'close_window')"},incognito:{type:"boolean",description:"If true, opens tab/window in incognito mode (optional for 'navigate', 'open_window', default: false)",default:!1},async:{type:"boolean",description:"When True, the operation will be performed asynchronously. Use false if you need to pause until the page has finished loading; e.g. if you plan to use extract_text next. (optional for 'navigate', default: false)",default:!1},withText:{type:"boolean",description:"When True, extract_text is returned after the operation has completed (optional for 'navigate', disables async mode, default: false)",default:!1},focus:{type:"boolean",description:"Bring tab to front. Usually required to make chrome activate, un-freeze, un-discard, and properly load the page (optional for tab operations, default: true)",default:!0},withScreenshot:{type:"boolean",description:"When True, screenshot is returned after the operation has completed (optional for 'navigate', disables async mode, default: false)",default:!1},close:{type:"boolean",description:"When True, the tab is closed after the operation has completed (optional for 'navigate', 'extract_text', 'extract_node_html', 'run_script_in_page', 'screenshot', default: false)",default:!1},nodeId:{type:"integer",description:"The nodeId number obtained from `extract_text` (required for 'extract_node_html' when getting element HTML)"},javascriptCode:{type:"string",description:"JavaScript code to evaluate in the page context (required for 'run_script_in_page')"},format:{type:"string",enum:["png","jpeg"],description:"Image format for screenshot (optional for 'screenshot', default: png)",default:"png"},quality:{type:"integer",description:"JPEG quality 0-100, ignored for PNG (optional for 'screenshot', default: 90)",minimum:0,maximum:100,default:90},clip:{type:"object",description:"Specific area to capture with x, y, width, height, scale properties (optional for 'screenshot')",properties:{x:{type:"number",description:"X coordinate of top-left corner"},y:{type:"number",description:"Y coordinate of top-left corner"},width:{type:"number",description:"Width of capture area"},height:{type:"number",description:"Height of capture area"},scale:{type:"number",description:"Device scale factor",default:1}},required:["x","y","width","height"]},captureBeyondViewport:{type:"boolean",description:"Capture content outside current viewport (optional for 'screenshot', default: false)",default:!1},fromSurface:{type:"boolean",description:"Capture from surface for better accuracy (optional for 'screenshot', default: true)",default:!0},setViewport:{type:"object",description:"Override viewport size before capture (optional for 'screenshot')",properties:{width:{type:"integer",description:"Viewport width"},height:{type:"integer",description:"Viewport height"},deviceScaleFactor:{type:"number",description:"Device scale factor",default:1},mobile:{type:"boolean",description:"Emulate mobile device",default:!1}},required:["width","height"]},returnAs:{type:"string",enum:["base64","dataUrl","blob"],description:"Format for returning image data (optional for 'screenshot', default: base64)",default:"base64"},saveToFile:{type:"string",description:"Filename to save screenshot and trigger download (optional for 'screenshot')"},text:{type:"string",description:"Search query text (optional for 'history_search')"},maxResults:{type:"integer",description:"Maximum number of history results to return (optional for 'history_search', default: 9999)",minimum:0,default:9999},visitCount:{type:"integer",description:"Maximum number of visits to return per history item (optional for 'history_search', default: 9, 0 for none)",minimum:0,default:9},startTime:{type:"string",description:"Start time for history_search. If omitted, only last 7 days are returned (use 0 to get all-time results). Accepts ISO strings (2025-07-02T14:30:00Z for UTC, 2025-07-02T14:30:00+10:00 for local with timezone. If no timezone specified, assumes user's local timezone.) or timestamps (milliseconds since epoch) (optional for 'history_search', 'history_delete_range', 'list_downloads')"},endTime:{type:"string",description:"End time for history_search (ISO string or timestamp) (optional for 'history_search', 'history_delete_range', 'list_downloads')"},urlToAdd:{type:"string",description:"URL to add to browser history (required for 'history_add_url' operation)"},title:{type:"string",description:"Title for the history entry (optional for 'history_add_url' operation)"},visitTime:{type:"string",description:"Visit time for history entry - ISO string or timestamp (optional for 'history_add_url' operation)"},transition:{type:"string",description:"Transition type for history entry: 'link', 'typed', 'auto_bookmark', 'auto_subframe', 'manual_subframe', 'generated', 'start_page', 'form_submit', 'reload', 'keyword', 'keyword_generated' (optional for 'history_add_url' operation)"},urlToDelete:{type:"string",description:"URL to remove from browser history (required for 'history_delete_url' operation)"},downloadUrl:{type:"string",description:"URL to download (required for 'download_file' operation)"},filename:{type:"string",description:"Suggested filename for download (optional for 'download_file' operation)"},saveAs:{type:"boolean",description:"Show save-as dialog for download (optional for 'download_file' operation, default: false)",default:!1},conflictAction:{type:"string",enum:["uniquify","overwrite","prompt"],description:"How to handle filename conflicts (optional for 'download_file' operation, default: uniquify)",default:"uniquify"},downloadId:{type:"integer",description:"Download ID for control operations (required for 'control_download' and 'show_download' actions)"},downloadAction:{type:"string",enum:["pause","resume","cancel"],description:"Control action to perform on download (required for 'control_download' operation)"},downloadQuery:{type:"string",description:"Search query for downloads (optional for 'list_downloads' operation)"},downloadState:{type:"string",enum:["in_progress","interrupted","complete"],description:"Filter downloads by state (optional for 'list_downloads' operation)"},downloadLimit:{type:"integer",description:"Maximum number of downloads to return (optional for 'list_downloads' operation, default: 100)",minimum:1,default:100},downloadOrderBy:{type:"string",enum:["startTime","totalBytes","filename","url"],description:"Sort downloads by field (optional for 'list_downloads' operation, default: startTime)",default:"startTime"},bookmarkId:{type:"string",description:"Bookmark ID for operations requiring specific bookmark (required for 'bookmark_get', 'bookmark_get_children', 'bookmark_remove', 'bookmark_remove_tree', 'bookmark_update', 'bookmark_move')"},bookmarkParentId:{type:"string",description:"Parent folder ID for bookmark creation or moving (required for 'bookmark_create', optional for 'bookmark_move')"},bookmarkTitle:{type:"string",description:"Title for bookmark or folder (required for 'bookmark_create', optional for 'bookmark_update')"},bookmarkUrl:{type:"string",description:"URL for bookmark creation or update (optional for 'bookmark_create' and 'bookmark_update', omit for folders)"},bookmarkIndex:{type:"integer",description:"Position index for bookmark creation or moving (optional for 'bookmark_create' and 'bookmark_move')"},bookmarkQuery:{type:"string",description:"Search query for bookmark search (required for 'bookmark_search')"},bookmarkSearchUrl:{type:"string",description:"URL to search for in bookmarks (optional for 'bookmark_search')"},bookmarkSearchTitle:{type:"string",description:"Title to search for in bookmarks (optional for 'bookmark_search')"},bookmarkDestinationParentId:{type:"string",description:"Destination parent folder ID for moving bookmarks (optional for 'bookmark_move')"},bookmarkDestinationIndex:{type:"integer",description:"Destination index for moving bookmarks (optional for 'bookmark_move')"},updateRuleOptions:{type:"object",description:"The options to pass into chrome.declarativeNetRequest.updateSessionRules() (required for 'update_session_rules')"}},required:["operation"]},callback_endpoint:"chrome-extension://browser-tool-callback",TOOL_API_KEY:"mcp_link_extension_browser_tool_auth_key_placeholder"}};function waitForTabToLoad(e,o=3e4){return new Promise((t,r)=>{chrome.tabs.get(e,n=>{if(chrome.runtime.lastError)return void r(chrome.runtime.lastError);if("complete"===n.status)return void t(n);let s,i=!1;const cleanup=()=>{chrome.tabs.onUpdated.removeListener(loadListener),chrome.tabs.onRemoved.removeListener(removeListener),s&&clearTimeout(s)},resolveOnce=e=>{i||(i=!0,cleanup(),t(e))},rejectOnce=e=>{i||(i=!0,cleanup(),r(e))},loadListener=(o,t,r)=>{o===e&&"complete"===t.status&&resolveOnce(r)},removeListener=o=>{o===e&&rejectOnce(new Error("Tab was closed before loading completed"))};chrome.tabs.onUpdated.addListener(loadListener),chrome.tabs.onRemoved.addListener(removeListener),s=setTimeout(()=>{rejectOnce(new Error(`Loading timed out after ${o}ms`))},o)})})}function parseBooleanParam(e,o=!1){if(null==e)return o;if("boolean"==typeof e)return e;if("string"==typeof e){const o=e.toLowerCase();return!("false"===o||"0"===o||"no"===o)}return"number"==typeof e?0!==e:o}function truncateDataUrl(e){if(!e||"string"!=typeof e)return e;const o=e.match(/^data:.*?,/);if(o){const t=o[0],r=undefined;return`${t} [${e.substring(t.length).length} characters truncated]`}return e}function convertBookmarksToTsv(e,o={}){if(!e||0===e.length)return"No bookmarks found.\n";const t=["id","parentId","index","title","url","dateAdded","dateGroupModified"],r=o.columns||t;function escapeTsvValue(e){if(null==e)return"-";let o=String(e);return"string"==typeof e&&(e.startsWith("http")||e.startsWith("data:"))&&(o=truncateDataUrl(o)),o.replace(/\t/g," ").replace(/\n/g," ").replace(/\r/g,"")}function flattenBookmarks(e,o=0){let t=[];for(const r of e){const e={...r,level:o};t.push(e),r.children&&r.children.length>0&&(t=t.concat(flattenBookmarks(r.children,o+1)))}return t}const n=flattenBookmarks(e);let s="\n"+r.join("\t")+"\tlevel\ttype\n";return n.forEach(e=>{const o=r.map(o=>{let t=e[o];return"type"===o&&(t=e.url?"bookmark":"folder"),escapeTsvValue(t)}).join("\t");s+=o+"\t"+e.level+"\t"+(e.url?"bookmark":"folder")+"\n"}),s}function parseTimeRangeParams(e,o=!0){const t={};function parseTimeParam(e){if(e){if("number"==typeof e)return e;if("string"==typeof e){if(/^\d{10,}(\.\d+)?$/.test(e.trim())){const o=parseFloat(e);if(!isNaN(o)&&isFinite(o))return o}try{const o=undefined,t=new Date(e).getTime();if(!isNaN(t))return console.log(`🕒 Parsed "${e}" as ${t} (${formatTimestampToLocal(t)})`),t}catch(o){console.warn(`⚠️ Failed to parse time parameter: ${e}`,o)}}}}if(o){const o=parseTimeParam(e.startTime),r=parseTimeParam(e.endTime);void 0!==o&&(t.startTime=o),void 0!==r&&(t.endTime=r)}return t}function parseHistoryParams(e){const o={text:e.text||""};if(void 0!==e.maxResults&&null!==e.maxResults){const t=parseInt(e.maxResults,10);!isNaN(t)&&t>=-1&&(o.maxResults=t)}if(void 0!==e.visitCount&&null!==e.visitCount){const t=parseInt(e.visitCount,10);!isNaN(t)&&t>=0&&(o.visitCount=t)}const t=parseTimeRangeParams(e);return Object.assign(o,t),o}function describeLocalTimeZone(){const e=Intl.DateTimeFormat().resolvedOptions().timeZone,o=new Intl.DateTimeFormat(void 0,{timeZoneName:"longOffset"}).formatToParts(new Date).find(e=>"timeZoneName"===e.type)?.value;return`All dates are in the user's local ${o} ${e} time zone`}function formatTimestampToLocal(e){const o=new Date(e),p=e=>e.toString().padStart(2,"0");return`${o.getFullYear()}-${p(o.getMonth()+1)}-${p(o.getDate())}T${p(o.getHours())}:${p(o.getMinutes())}:${p(o.getSeconds())}`}async function searchHistory(e){return console.log("🔍 [searchHistory] Starting search with params:",JSON.stringify(e,null,2)),new Promise((o,t)=>{const r={text:e.text,maxResults:e.maxResults};void 0!==e.startTime&&(r.startTime=e.startTime,console.log(`🕒 [searchHistory] Start time: ${e.startTime} (${formatTimestampToLocal(e.startTime)})`)),void 0!==e.endTime&&(r.endTime=e.endTime,console.log(`🕒 [searchHistory] End time: ${e.endTime} (${formatTimestampToLocal(e.endTime)})`)),console.log("🔍 [searchHistory] Chrome API query object:",{query:r,json_query:JSON.stringify(r,null,2)}),chrome.history.search(r,e=>{if(chrome.runtime.lastError){const e=chrome.runtime.lastError?.message||JSON.stringify(chrome.runtime.lastError);return console.error("❌ [searchHistory] Chrome API error:",chrome.runtime.lastError),void t(new Error(`History search failed: ${e}`))}console.log(`✅ [searchHistory] Chrome API returned ${e?e.length:0} results`),console.log("📊 [searchHistory] Full results object:",JSON.stringify(e,null,2)),o({success:!0,data:e||[],query:r})})})}async function getHistoryVisits(e){return console.log(`🔍 [getHistoryVisits] Getting visits for URL: ${e}`),new Promise((o,t)=>{chrome.history.getVisits({url:e},r=>{if(chrome.runtime.lastError){const o=chrome.runtime.lastError?.message||JSON.stringify(chrome.runtime.lastError);return console.error(`❌ [getHistoryVisits] Chrome API error for ${e}:`,chrome.runtime.lastError),void t(new Error(`Get visits failed for ${e}: ${o}`))}console.log(`✅ [getHistoryVisits] Found ${r?r.length:0} visits for ${e}`),console.log(`📊 [getHistoryVisits] Full visits object for ${e}:`,JSON.stringify(r,null,2)),o({success:!0,data:r||[],url:e})})})}async function addUrlToHistory(e){return console.log("➕ [addUrlToHistory] Adding URL with details:",JSON.stringify(e,null,2)),new Promise((o,t)=>{chrome.history.addUrl(e,()=>{if(chrome.runtime.lastError){const e=chrome.runtime.lastError?.message||JSON.stringify(chrome.runtime.lastError);return console.error("❌ [addUrlToHistory] Chrome API error:",chrome.runtime.lastError),void t(new Error(`Add URL failed: ${e}`))}console.log(`✅ [addUrlToHistory] Successfully added URL: ${e.url}`),console.log("📊 [addUrlToHistory] Details sent to Chrome API:",JSON.stringify(e,null,2)),o({success:!0,url:e.url,details:e,message:`Successfully added URL to history: ${e.url}`})})})}async function deleteUrlFromHistory(e){return console.log(`🗑️ [deleteUrlFromHistory] Deleting URL: ${e}`),new Promise((o,t)=>{chrome.history.deleteUrl({url:e},()=>{if(chrome.runtime.lastError){const e=chrome.runtime.lastError?.message||JSON.stringify(chrome.runtime.lastError);return console.error("❌ [deleteUrlFromHistory] Chrome API error:",chrome.runtime.lastError),void t(new Error(`Delete URL failed: ${e}`))}console.log(`✅ [deleteUrlFromHistory] Successfully deleted URL: ${e}`),o({success:!0,url:e,message:`Successfully deleted URL from history: ${e}`})})})}async function deleteHistoryRange(e,o){const t={startTime:e,endTime:o};return console.log("🗑️ [deleteHistoryRange] Deleting range:",JSON.stringify(t,null,2)),console.log(`🕒 [deleteHistoryRange] Range: ${formatTimestampToLocal(e)} to ${formatTimestampToLocal(o)}`),new Promise((r,n)=>{chrome.history.deleteRange(t,()=>{if(chrome.runtime.lastError){const e=chrome.runtime.lastError?.message||JSON.stringify(chrome.runtime.lastError);return console.error("❌ [deleteHistoryRange] Chrome API error:",chrome.runtime.lastError),void n(new Error(`Delete range failed: ${e}`))}const t=formatTimestampToLocal(e),s=formatTimestampToLocal(o);console.log(`✅ [deleteHistoryRange] Successfully deleted range from ${t} to ${s}`),r({success:!0,startTime:e,endTime:o,startFormatted:t,endFormatted:s,message:`Successfully deleted history range from ${t} to ${s}`})})})}async function deleteAllHistory(){return console.log("🗑️ [deleteAllHistory] Deleting all browser history"),new Promise((e,o)=>{chrome.history.deleteAll(()=>{if(chrome.runtime.lastError){const e=chrome.runtime.lastError?.message||JSON.stringify(chrome.runtime.lastError);return console.error("❌ [deleteAllHistory] Chrome API error:",chrome.runtime.lastError),void o(new Error(`Delete all failed: ${e}`))}console.log("✅ [deleteAllHistory] Successfully deleted all browser history"),e({success:!0,message:"Successfully deleted all browser history"})})})}function extractTabText(e,o=!1,t=""){getPageText({id:e},"").then(r=>{if(console.log("Got page text result:",r),r.success){const o=t?`${t}\n`:"",n=`tabId: ${String(e)}\n${o}\n${r.data}`;sendResult({content:[{type:"text",text:n}],isError:!1})}else{const e=`Error getting page text: ${r.error}`;sendResult({content:[{type:"text",text:e}],isError:!0})}o&&chrome.tabs.remove(e,()=>{chrome.runtime.lastError?console.warn(`⚠️ Failed to close tab ${e}:`,chrome.runtime.lastError.message):console.log(`🔍 DEBUG: closing tab ${e}`)})}).catch(t=>{sendResult({content:[{type:"text",text:`Error getting page text: ${t.message||t.toString()}`}],isError:!0}),console.error("Error getting page text:",t),o&&chrome.tabs.remove(e,()=>{chrome.runtime.lastError?console.warn(`⚠️ Failed to close tab ${e}:`,chrome.runtime.lastError.message):console.log(`🔍 DEBUG: closing tab ${e}`)})})}function extractNodeHTML(e,o,t=!1,r=null){getOuterHTMLFromNodeId({id:e},o,r).then(n=>{if(console.log("Got node html result:",n),n.success){const t=`tabId: ${String(e)}${o?`\nnodeId: ${String(o)}`:""}\n${r?"result":"outerHTML"}:-\n\n${n.data}`;sendResult({content:[{type:"text",text:t}],isError:!1})}else{const e=`Error getting ${r?"js result":"node html"}: ${n.error}`;sendResult({content:[{type:"text",text:e}],isError:!0})}t&&chrome.tabs.remove(e,()=>{chrome.runtime.lastError?console.warn(`⚠️ Failed to close tab ${e}:`,chrome.runtime.lastError.message):console.log(`🔍 DEBUG: closing tab ${e}`)})}).catch(o=>{sendResult({content:[{type:"text",text:`Error getting ${r?"js result":"node html"}: ${o.message||o.toString()}`}],isError:!0}),console.error("Error getting node html:",o),t&&chrome.tabs.remove(e,()=>{chrome.runtime.lastError?console.warn(`⚠️ Failed to close tab ${e}:`,chrome.runtime.lastError.message):console.log(`🔍 DEBUG: closing tab ${e}`)})})}function captureTabScreenshot(e,o=!1,t=""){const r={format:"png",quality:90,captureBeyondViewport:!1,fromSurface:!0,returnAs:"base64"};captureScreenshotFromTab(e,r).then(n=>{if(console.log("Got screenshot result:",n.success?"success":n.error),n.success){const o=t?`${t}\n`:"",s=`tabId: ${String(e)}\n${o}format: ${r.format}\nsize: ${n.data.length} bytes\n\n${n.data}`;sendResult({content:[{type:"text",text:s}],isError:!1})}else{const e=`Error capturing screenshot: ${n.error}`;sendResult({content:[{type:"text",text:e}],isError:!0})}o&&chrome.tabs.remove(e,()=>{chrome.runtime.lastError?console.warn(`⚠️ Failed to close tab ${e}:`,chrome.runtime.lastError.message):console.log(`🔍 DEBUG: closing tab ${e}`)})}).catch(t=>{sendResult({content:[{type:"text",text:`Error capturing screenshot: ${t.message||t.toString()}`}],isError:!0}),console.error("Error capturing screenshot:",t),o&&chrome.tabs.remove(e,()=>{chrome.runtime.lastError?console.warn(`⚠️ Failed to close tab ${e}:`,chrome.runtime.lastError.message):console.log(`🔍 DEBUG: closing tab ${e}`)})})}function captureScreenshotFromTab(e,o={}){return new Promise((t,r)=>{chrome.debugger.attach({tabId:e},"1.3",()=>{if(chrome.runtime.lastError)return void r(new Error(`Failed to attach debugger: ${chrome.runtime.lastError.message}`));const cleanup=()=>{chrome.debugger.detach({tabId:e},()=>{})},n={format:o.format||"png",quality:"jpeg"===o.format?o.quality||90:void 0,captureBeyondViewport:o.captureBeyondViewport||!1,fromSurface:!1!==o.fromSurface};o.clip&&(n.clip={x:o.clip.x,y:o.clip.y,width:o.clip.width,height:o.clip.height,scale:o.clip.scale||1});const s=undefined;(o.setViewport?new Promise((t,r)=>{chrome.debugger.sendCommand({tabId:e},"Emulation.setDeviceMetricsOverride",{width:o.setViewport.width,height:o.setViewport.height,deviceScaleFactor:o.setViewport.deviceScaleFactor||1,mobile:o.setViewport.mobile||!1},e=>{chrome.runtime.lastError?r(new Error(`Failed to set viewport: ${chrome.runtime.lastError.message}`)):t(e)})}):Promise.resolve()).then(()=>{chrome.debugger.sendCommand({tabId:e},"Page.captureScreenshot",n,e=>{if(cleanup(),chrome.runtime.lastError)return void r(new Error(`Failed to capture screenshot: ${chrome.runtime.lastError.message}`));if(!e||!e.data)return void r(new Error("Screenshot capture returned no data"));let s;switch(o.returnAs){case"dataUrl":s=`data:image/${n.format};base64,${e.data}`;break;case"blob":s=`blob:${e.data}`;break;default:s=e.data}if(o.saveToFile){const t=`data:image/${n.format};base64,${e.data}`;chrome.downloads.download({url:t,filename:o.saveToFile},e=>{chrome.runtime.lastError&&console.warn("Failed to trigger download:",chrome.runtime.lastError.message)})}t({success:!0,data:s,format:n.format,size:e.data.length})})}).catch(e=>{cleanup(),r(e)})})})}async function downloadFile(e){return console.log("⬇️ [downloadFile] Starting download with options:",JSON.stringify(e,null,2)),new Promise((o,t)=>{chrome.downloads.download(e,r=>{if(chrome.runtime.lastError){const e=chrome.runtime.lastError?.message||JSON.stringify(chrome.runtime.lastError);return console.error("❌ [downloadFile] Chrome API error:",chrome.runtime.lastError),void t(new Error(`Download failed: ${e}`))}console.log(`✅ [downloadFile] Successfully started download with ID: ${r}`),console.log("📊 [downloadFile] Options sent to Chrome API:",JSON.stringify(e,null,2)),o({success:!0,downloadId:r,url:truncateDataUrl(e.url),filename:e.filename,message:`Successfully started download (ID: ${r}): ${truncateDataUrl(e.url)}`})})})}async function searchDownloads(e){return console.log("🔍 [searchDownloads] Searching downloads with query:",JSON.stringify(e,null,2)),new Promise((o,t)=>{chrome.downloads.search(e,r=>{if(chrome.runtime.lastError){const e=chrome.runtime.lastError?.message||JSON.stringify(chrome.runtime.lastError);return console.error("❌ [searchDownloads] Chrome API error:",chrome.runtime.lastError),void t(new Error(`Download search failed: ${e}`))}console.log(`✅ [searchDownloads] Chrome API returned ${r?r.length:0} results`),console.log("📊 [searchDownloads] Full results object:",JSON.stringify(r,null,2)),o({success:!0,data:r||[],query:e})})})}async function controlDownload(e,o){return console.log(`🎮 [controlDownload] ${o} download ID: ${e}`),new Promise((o,t)=>{const r=chrome.downloads[r];r?r(e,()=>{if(chrome.runtime.lastError){const e=chrome.runtime.lastError?.message||JSON.stringify(chrome.runtime.lastError);return console.error(`❌ [controlDownload] Chrome API error for ${r}:`,chrome.runtime.lastError),void t(new Error(`Download ${r} failed: ${e}`))}console.log(`✅ [controlDownload] Successfully ${r}ed download ID: ${e}`),o({success:!0,downloadId:e,operation:r,message:`Successfully ${r}ed download ID: ${e}`})}):t(new Error(`Invalid download operation: ${r}`))})}async function showDownload(e){return console.log(`👁️ [showDownload] Showing download ID: ${e}`),new Promise((o,t)=>{try{if(chrome.downloads.show(e),chrome.runtime.lastError){const e=chrome.runtime.lastError?.message||JSON.stringify(chrome.runtime.lastError);return console.error("❌ [showDownload] Chrome API error:",chrome.runtime.lastError),void t(new Error(`Show download failed: ${e}`))}console.log(`✅ [showDownload] Successfully showed download ID: ${e}`),o({success:!0,downloadId:e,message:`Successfully showed download ID: ${e} in file manager`})}catch(e){console.error("❌ [showDownload] Exception:",e),t(new Error(`Show download failed: ${e.message}`))}})}function parseDownloadParams(e){const o={};if(void 0!==e.downloadLimit&&null!==e.downloadLimit){const t=parseInt(e.downloadLimit,10);!isNaN(t)&&t>=1&&(o.limit=t)}e.downloadQuery&&(o.query=Array.isArray(e.downloadQuery)?e.downloadQuery:[e.downloadQuery]),e.downloadState&&(o.state=e.downloadState),e.downloadOrderBy&&(o.orderBy=[e.downloadOrderBy]);const t=parseTimeRangeParams(e);return void 0!==t.startTime&&(o.startedAfter=new Date(t.startTime).toISOString()),void 0!==t.endTime&&(o.startedBefore=new Date(t.endTime).toISOString()),o}async function createBookmark(e){return console.log("🔖 [createBookmark] Creating bookmark with details:",JSON.stringify(e,null,2)),new Promise((o,t)=>{chrome.bookmarks.create(e,e=>{if(chrome.runtime.lastError){const e=chrome.runtime.lastError?.message||JSON.stringify(chrome.runtime.lastError);return console.error("❌ [createBookmark] Chrome API error:",chrome.runtime.lastError),void t(new Error(`Create bookmark failed: ${e}`))}console.log("✅ [createBookmark] Successfully created bookmark:",JSON.stringify(e,null,2)),o({success:!0,bookmark:e,message:`Successfully created ${e.url?"bookmark":"folder"}: ${e.title}`})})})}async function searchBookmarks(e){return console.log("🔖 [searchBookmarks] Searching bookmarks with query:",JSON.stringify(e,null,2)),new Promise((o,t)=>{chrome.bookmarks.search(e,r=>{if(chrome.runtime.lastError){const e=chrome.runtime.lastError?.message||JSON.stringify(chrome.runtime.lastError);return console.error("❌ [searchBookmarks] Chrome API error:",chrome.runtime.lastError),void t(new Error(`Search bookmarks failed: ${e}`))}console.log(`✅ [searchBookmarks] Found ${r?r.length:0} bookmarks`),console.log("📊 [searchBookmarks] Results:",JSON.stringify(r,null,2)),o({success:!0,data:r||[],count:r?r.length:0,query:e})})})}async function getBookmark(e){return console.log(`🔖 [getBookmark] Getting bookmark: ${e}`),new Promise((o,t)=>{chrome.bookmarks.get(e,r=>{if(chrome.runtime.lastError){const e=chrome.runtime.lastError?.message||JSON.stringify(chrome.runtime.lastError);return console.error("❌ [getBookmark] Chrome API error:",chrome.runtime.lastError),void t(new Error(`Get bookmark failed: ${e}`))}console.log(`✅ [getBookmark] Retrieved ${r?r.length:0} bookmarks`),console.log("📊 [getBookmark] Results:",JSON.stringify(r,null,2)),o({success:!0,data:r||[],message:`Successfully retrieved bookmark: ${e}`})})})}async function getBookmarkTree(){return console.log("🔖 [getBookmarkTree] Getting entire bookmark tree"),new Promise((e,o)=>{chrome.bookmarks.getTree(t=>{if(chrome.runtime.lastError){const e=chrome.runtime.lastError?.message||JSON.stringify(chrome.runtime.lastError);return console.error("❌ [getBookmarkTree] Chrome API error:",chrome.runtime.lastError),void o(new Error(`Get bookmark tree failed: ${e}`))}console.log("✅ [getBookmarkTree] Retrieved bookmark tree"),console.log("📊 [getBookmarkTree] Tree structure:",JSON.stringify(t,null,2)),e({success:!0,data:t||[],message:"Successfully retrieved entire bookmark tree"})})})}async function getBookmarkChildren(e){return console.log(`🔖 [getBookmarkChildren] Getting children of bookmark: ${e}`),new Promise((o,t)=>{chrome.bookmarks.getChildren(e,r=>{if(chrome.runtime.lastError){const e=chrome.runtime.lastError?.message||JSON.stringify(chrome.runtime.lastError);return console.error("❌ [getBookmarkChildren] Chrome API error:",chrome.runtime.lastError),void t(new Error(`Get bookmark children failed: ${e}`))}console.log(`✅ [getBookmarkChildren] Retrieved ${r?r.length:0} children`),console.log("📊 [getBookmarkChildren] Children:",JSON.stringify(r,null,2)),o({success:!0,data:r||[],count:r?r.length:0,message:`Successfully retrieved ${r?r.length:0} children for bookmark: ${e}`})})})}async function removeBookmark(e){return console.log(`🔖 [removeBookmark] Removing bookmark: ${e}`),new Promise((o,t)=>{chrome.bookmarks.remove(e,()=>{if(chrome.runtime.lastError){const e=chrome.runtime.lastError?.message||JSON.stringify(chrome.runtime.lastError);return console.error("❌ [removeBookmark] Chrome API error:",chrome.runtime.lastError),void t(new Error(`Remove bookmark failed: ${e}`))}console.log(`✅ [removeBookmark] Successfully removed bookmark: ${e}`),o({success:!0,bookmarkId:e,message:`Successfully removed bookmark: ${e}`})})})}async function removeBookmarkTree(e){return console.log(`🔖 [removeBookmarkTree] Removing bookmark tree: ${e}`),new Promise((o,t)=>{chrome.bookmarks.removeTree(e,()=>{if(chrome.runtime.lastError){const e=chrome.runtime.lastError?.message||JSON.stringify(chrome.runtime.lastError);return console.error("❌ [removeBookmarkTree] Chrome API error:",chrome.runtime.lastError),void t(new Error(`Remove bookmark tree failed: ${e}`))}console.log(`✅ [removeBookmarkTree] Successfully removed bookmark tree: ${e}`),o({success:!0,bookmarkId:e,message:`Successfully removed bookmark tree: ${e}`})})})}async function updateBookmark(e,o){return console.log(`🔖 [updateBookmark] Updating bookmark ${e} with changes:`,JSON.stringify(o,null,2)),new Promise((t,r)=>{chrome.bookmarks.update(e,o,e=>{if(chrome.runtime.lastError){const e=chrome.runtime.lastError?.message||JSON.stringify(chrome.runtime.lastError);return console.error("❌ [updateBookmark] Chrome API error:",chrome.runtime.lastError),void r(new Error(`Update bookmark failed: ${e}`))}console.log("✅ [updateBookmark] Successfully updated bookmark:",JSON.stringify(e,null,2)),t({success:!0,bookmark:e,changes:o,message:`Successfully updated bookmark: ${e.title}`})})})}async function moveBookmark(e,o){return console.log(`🔖 [moveBookmark] Moving bookmark ${e} to destination:`,JSON.stringify(o,null,2)),new Promise((t,r)=>{chrome.bookmarks.move(e,o,e=>{if(chrome.runtime.lastError){const e=chrome.runtime.lastError?.message||JSON.stringify(chrome.runtime.lastError);return console.error("❌ [moveBookmark] Chrome API error:",chrome.runtime.lastError),void r(new Error(`Move bookmark failed: ${e}`))}console.log("✅ [moveBookmark] Successfully moved bookmark:",JSON.stringify(e,null,2)),t({success:!0,bookmark:e,destination:o,message:`Successfully moved bookmark: ${e.title}`})})})}function createNewTabWithPosition(e,o,t,r,n,s,i,a,l,d){t&&n&&console.log("🔄 Conflict resolution: openerTabId + windowId => openerTabId wins");const c=undefined;(()=>new Promise((e,o)=>{t?chrome.tabs.get(t,r=>{chrome.runtime.lastError?o(new Error(`Invalid openerTabId ${t}: ${chrome.runtime.lastError.message}`)):e({windowId:r.windowId,foundByOpener:!0})}):n?chrome.windows.get(n,window=>{chrome.runtime.lastError?o(new Error(`Invalid windowId ${n}: ${chrome.runtime.lastError.message}`)):e({windowId:n,foundByOpener:!1})}):s?findOrCreateIncognitoWindow().then(e).catch(o):chrome.windows.getCurrent(t=>{chrome.runtime.lastError?o(new Error(`Failed to get current window: ${chrome.runtime.lastError.message}`)):e({windowId:t.id,foundByOpener:!1})})}))().then(({windowId:o,foundByOpener:n,createdWindow:s})=>{const c={url:e,active:!0,windowId:o};t&&(c.openerTabId=t),null!=r&&(c.index=r),console.log("🆕 Creating tab with properties:",c),chrome.tabs.create(c,e=>{if(chrome.runtime.lastError)return console.error("❌ Failed to create tab:",chrome.runtime.lastError),void sendResult({content:[{type:"text",text:"Failed to create tab: "+chrome.runtime.lastError.message}],isError:!0});console.log(`✅ Successfully created tab: ${e.id} in window: ${o}`),handleTabLoadCompletion(e,s?o:null,i,a,l,d)})}).catch(e=>{console.error("❌ Failed to determine target window:",e),sendResult({content:[{type:"text",text:e.message}],isError:!0})})}function findOrCreateIncognitoWindow(){return new Promise((e,o)=>{chrome.windows.getAll({windowTypes:["normal"]},t=>{if(chrome.runtime.lastError)return void o(new Error(`Failed to query windows: ${chrome.runtime.lastError.message}`));const r=t.find(e=>e.incognito);if(r)return console.log(`🔍 Found existing incognito window: ${r.id}`),void e({windowId:r.id,foundByOpener:!1});console.log("🆕 Creating new incognito window"),chrome.windows.create({incognito:!0},t=>{chrome.runtime.lastError?o(new Error(`Failed to create incognito window: ${chrome.runtime.lastError.message}`)):(console.log(`✅ Created incognito window: ${t.id}`),e({windowId:t.id,foundByOpener:!1,createdWindow:!0}))})})})}function handleTabLoadCompletion(e,o,t,r,n,s){if(t){const t=o?`\nwindowId: ${o}`:"";sendResult({content:[{type:"text",text:`Successfully opened tabId: ${e.id}${t}`}],isError:!1})}else waitForTabToLoad(e.id).then(()=>{if(r){const t=o?`windowId: ${o}`:"";extractTabText(e.id,s,t)}else if(n){const t=o?`windowId: ${o}`:"";captureTabScreenshot(e.id,s,t)}else{const t=o?`\nwindowId: ${o}`:"";sendResult({content:[{type:"text",text:`Successfully opened and loaded tabId: ${e.id}${t}`}],isError:!1})}}).catch(t=>{const r=o?`\nwindowId: ${o}`:"";sendResult({content:[{type:"text",text:`tabId ${e.id} created${r}, but loading failed: ${t}`}],isError:!0}),console.log(`🔍 DEBUG: on error... closing tab ${e.id}`),s&&chrome.tabs.remove(e.id,()=>{chrome.runtime.lastError&&console.warn(`⚠️ Failed to close tab ${e.id}:`,chrome.runtime.lastError.message)})})}self.browser=e=>{a.log("msg=",e);let o="error";if(sendResult=o=>{e.mcpClient.sendRequest("tools/reply",{name:e.reverse.tool,result:o,call_id:e.reverse.call_id,id:e.id},e.id)},"mcp_tools_update"===e?.type){const t=e.tools?.tools?.[e.serverId]?.tools?.some(e=>"remote"===e.name);a.log("mcp_tools_update hasRemoteTool:",t);const r=e.mcpClient?.messageEndpoint??e.serverId,n=k[r];return a.log(`already_registered_with_this_server for ${e.serverId}:`,n),t&&!n?(globalThis.pop_get({prop:"settings.enable_browser_tool",ret:"local_response"}).then(o=>{o?(e.mcpClient.sendRequest("tools/call",{name:"remote",arguments:y}).then(e=>{a.log(`Sent browser tool registration, call ID: ${e}`),k[r]=!0}).catch(e=>{a.log("Failed to register browser tool:",e)}),a.log("sent tool registration payload:",y)):a.log("⚠️ browser tool disabled in settings")}),o="tool_registration_queued_for_enable_check"):t&&n?(a.log(`skipping registration - already registered with server ${e.serverId}`),o="already_registered"):(a.log("no tool 'remote' - not registering this tool with server ",e?.serverId),o="tool_not_registered"),{operation:o,hasRemoteTool:t,serverId:e.serverId,original_msg:e}}if(e?.reverse){a.log("⚡ Performing browser tool operation: msg:",e);let s=e.reverse?.input?.params?.arguments?.operation?.toLowerCase(),i={content:[{type:"text",text:`Unknown browser operation "${s}" {see readme}`}],isError:!0};const l=parseBooleanParam(e.reverse?.input?.params?.arguments?.focus,!0),d=parseBooleanParam(e.reverse?.input?.params?.arguments?.withText,!1),c=parseBooleanParam(e.reverse?.input?.params?.arguments?.withScreenshot,!1),m=!d&&!c&&parseBooleanParam(e.reverse?.input?.params?.arguments?.async,!0),u=parseBooleanParam(e.reverse?.input?.params?.arguments?.close,!1);let g=null;const h=e.reverse?.input?.params?.arguments?.tabId;if(null!=h&&(g=parseInt(h,10),isNaN(g)))return console.error("❌ Invalid tabId: must be a number, got:",h),void sendResult({content:[{type:"text",text:"Invalid tabId: must be a number"}],isError:!0});let f=null;const b=e.reverse?.input?.params?.arguments?.nodeId;if(null!=b&&(f=parseInt(b,10),isNaN(f)))return console.error("❌ Invalid nodeId: must be a number, got:",b),void sendResult({content:[{type:"text",text:"Invalid nodeId: must be a number"}],isError:!0});const w=e.reverse?.input?.params?.arguments?.javascriptCode;if("focus_tab"===s)return null===g?(console.error("❌ Focus tab operation missing tabId parameter"),void sendResult({content:[{type:"text",text:"Focus tab operation missing tabId parameter"}],isError:!0})):(console.log(`🔍 Focusing tab ${g}`),void chrome.tabs.update(g,{active:!0},function(e){if(chrome.runtime.lastError)return console.error("❌ Failed to focus tab:",chrome.runtime.lastError),void sendResult({content:[{type:"text",text:"Failed to focus tab "+g+": "+chrome.runtime.lastError.message}],isError:!0});console.log(`✅ Successfully focused tab ${g}`),sendResult({content:[{type:"text",text:"Tab "+g+" focused"}],isError:!1})}));if("go_back"===s)return null===g?(console.error("❌ Go back operation missing tabId parameter"),void sendResult({content:[{type:"text",text:"Go back operation missing tabId parameter"}],isError:!0})):(console.log(`⬅️ Going back in tab ${g}`),void chrome.tabs.goBack(g,function(){if(chrome.runtime.lastError)return console.error("❌ Failed to go back:",chrome.runtime.lastError),void sendResult({content:[{type:"text",text:"Failed to go back in tab "+g+": "+chrome.runtime.lastError.message}],isError:!0});console.log(`✅ Successfully went back in tab ${g}`),sendResult({content:[{type:"text",text:"Tab "+g+" navigated back"}],isError:!1})}));if("go_forward"===s)return null===g?(console.error("❌ Go forward operation missing tabId parameter"),void sendResult({content:[{type:"text",text:"Go forward operation missing tabId parameter"}],isError:!0})):(console.log(`➡️ Going forward in tab ${g}`),void chrome.tabs.goForward(g,function(){if(chrome.runtime.lastError)return console.error("❌ Failed to go forward:",chrome.runtime.lastError),void sendResult({content:[{type:"text",text:"Failed to go forward in tab "+g+": "+chrome.runtime.lastError.message}],isError:!0});console.log(`✅ Successfully went forward in tab ${g}`),sendResult({content:[{type:"text",text:"Tab "+g+" navigated forward"}],isError:!1})}));if("extension_reload"===s)return console.log("🔄 Extension reload requested"),sendResult({content:[{type:"text",text:"Extension reloading in 1 second..."}],isError:!1}),void setTimeout(()=>{chrome.runtime.reload()},1e3);if("bookmark_create"===s){console.log("🔖 Create bookmark request");const v=e.reverse?.input?.params?.arguments||{};console.log("🔖 [bookmark_create] Raw arguments:",JSON.stringify(v,null,2));const E=v.bookmarkParentId,x=v.bookmarkTitle,_=v.bookmarkUrl,T=v.bookmarkIndex;if(!x)return console.error("❌ Create bookmark operation missing bookmarkTitle parameter"),void sendResult({content:[{type:"text",text:"Create bookmark operation requires bookmarkTitle parameter"}],isError:!0});const R={title:x};return E&&(R.parentId=E),_&&(R.url=_),null!=T&&(R.index=parseInt(T,10),isNaN(R.index))?(console.error("❌ Invalid bookmarkIndex: must be a number, got:",T),void sendResult({content:[{type:"text",text:"Invalid bookmarkIndex: must be a number"}],isError:!0})):(console.log("🔖 Creating bookmark:",R),void createBookmark(R).then(e=>{console.log("✅ [bookmark_create] Operation result:",JSON.stringify(e,null,2)),sendResult({content:[{type:"text",text:JSON.stringify(e,null,2)}],isError:!1})}).catch(e=>{console.error("❌ [bookmark_create] Operation failed:",e),e.message&&e.message.includes("permission")?sendResult({content:[{type:"text",text:"Bookmarks permission not granted. Please enable bookmarks permission in extension settings."}],isError:!0}):sendResult({content:[{type:"text",text:"Failed to create bookmark: "+e.message}],isError:!0})}))}if("bookmark_search"===s){console.log("🔖 Search bookmarks request");const I=e.reverse?.input?.params?.arguments||{};let S;if(console.log("🔖 [bookmark_search] Raw arguments:",JSON.stringify(I,null,2)),I.bookmarkQuery)S=I.bookmarkQuery;else{if(!I.bookmarkSearchUrl&&!I.bookmarkSearchTitle)return console.error("❌ Search bookmarks operation missing search parameters"),void sendResult({content:[{type:"text",text:"Search bookmarks operation requires bookmarkQuery, bookmarkSearchUrl, or bookmarkSearchTitle parameter"}],isError:!0});S={},I.bookmarkSearchUrl&&(S.url=I.bookmarkSearchUrl),I.bookmarkSearchTitle&&(S.title=I.bookmarkSearchTitle)}return console.log("🔖 Searching bookmarks:",S),void searchBookmarks(S).then(e=>{console.log(`✅ [bookmark_search] Operation completed with ${e.data?e.data.length:0} matches`);const o=convertBookmarksToTsv(e.data||[]);sendResult({content:[{type:"text",text:o}],isError:!1})}).catch(e=>{console.error("❌ [bookmark_search] Operation failed:",e),e.message&&e.message.includes("permission")?sendResult({content:[{type:"text",text:"Bookmarks permission not granted. Please enable bookmarks permission in extension settings."}],isError:!0}):sendResult({content:[{type:"text",text:"Failed to search bookmarks: "+e.message}],isError:!0})})}if("bookmark_get"===s){console.log("🔖 Get bookmark request");const $=e.reverse?.input?.params?.arguments||{};console.log("🔖 [bookmark_get] Raw arguments:",JSON.stringify($,null,2));const O=$.bookmarkId;return O?(console.log(`🔖 Getting bookmark: ${O}`),void getBookmark(O).then(e=>{console.log("✅ [bookmark_get] Operation result:",JSON.stringify(e,null,2)),sendResult({content:[{type:"text",text:JSON.stringify(e,null,2)}],isError:!1})}).catch(e=>{console.error("❌ [bookmark_get] Operation failed:",e),e.message&&e.message.includes("permission")?sendResult({content:[{type:"text",text:"Bookmarks permission not granted. Please enable bookmarks permission in extension settings."}],isError:!0}):sendResult({content:[{type:"text",text:"Failed to get bookmark: "+e.message}],isError:!0})})):(console.error("❌ Get bookmark operation missing bookmarkId parameter"),void sendResult({content:[{type:"text",text:"Get bookmark operation requires bookmarkId parameter"}],isError:!0}))}if("bookmark_get_tree"===s)return console.log("🔖 Get bookmark tree request"),console.log("🔖 Getting entire bookmark tree"),void getBookmarkTree().then(e=>{console.log(`✅ [bookmark_get_tree] Operation completed with ${e.data?e.data.length:0} root items`);const o=convertBookmarksToTsv(e.data||[]);sendResult({content:[{type:"text",text:o}],isError:!1})}).catch(e=>{console.error("❌ [bookmark_get_tree] Operation failed:",e),e.message&&e.message.includes("permission")?sendResult({content:[{type:"text",text:"Bookmarks permission not granted. Please enable bookmarks permission in extension settings."}],isError:!0}):sendResult({content:[{type:"text",text:"Failed to get bookmark tree: "+e.message}],isError:!0})});if("bookmark_get_children"===s){console.log("🔖 Get bookmark children request");const N=e.reverse?.input?.params?.arguments||{};console.log("🔖 [bookmark_get_children] Raw arguments:",JSON.stringify(N,null,2));const D=N.bookmarkId;return D?(console.log(`🔖 Getting bookmark children: ${D}`),void getBookmarkChildren(D).then(e=>{console.log(`✅ [bookmark_get_children] Operation completed with ${e.data?e.data.length:0} children`);const o=convertBookmarksToTsv(e.data||[]);sendResult({content:[{type:"text",text:o}],isError:!1})}).catch(e=>{console.error("❌ [bookmark_get_children] Operation failed:",e),e.message&&e.message.includes("permission")?sendResult({content:[{type:"text",text:"Bookmarks permission not granted. Please enable bookmarks permission in extension settings."}],isError:!0}):sendResult({content:[{type:"text",text:"Failed to get bookmark children: "+e.message}],isError:!0})})):(console.error("❌ Get bookmark children operation missing bookmarkId parameter"),void sendResult({content:[{type:"text",text:"Get bookmark children operation requires bookmarkId parameter"}],isError:!0}))}if("bookmark_remove"===s){console.log("🔖 Remove bookmark request");const P=e.reverse?.input?.params?.arguments||{};console.log("🔖 [bookmark_remove] Raw arguments:",JSON.stringify(P,null,2));const C=P.bookmarkId;return C?(console.log(`🔖 Removing bookmark: ${C}`),void removeBookmark(C).then(e=>{console.log("✅ [bookmark_remove] Operation result:",JSON.stringify(e,null,2)),sendResult({content:[{type:"text",text:JSON.stringify(e,null,2)}],isError:!1})}).catch(e=>{console.error("❌ [bookmark_remove] Operation failed:",e),e.message&&e.message.includes("permission")?sendResult({content:[{type:"text",text:"Bookmarks permission not granted. Please enable bookmarks permission in extension settings."}],isError:!0}):sendResult({content:[{type:"text",text:"Failed to remove bookmark: "+e.message}],isError:!0})})):(console.error("❌ Remove bookmark operation missing bookmarkId parameter"),void sendResult({content:[{type:"text",text:"Remove bookmark operation requires bookmarkId parameter"}],isError:!0}))}if("bookmark_remove_tree"===s){console.log("🔖 Remove bookmark tree request");const A=e.reverse?.input?.params?.arguments||{};console.log("🔖 [bookmark_remove_tree] Raw arguments:",JSON.stringify(A,null,2));const U=A.bookmarkId;return U?(console.log(`🔖 Removing bookmark tree: ${U}`),void removeBookmarkTree(U).then(e=>{console.log("✅ [bookmark_remove_tree] Operation result:",JSON.stringify(e,null,2)),sendResult({content:[{type:"text",text:JSON.stringify(e,null,2)}],isError:!1})}).catch(e=>{console.error("❌ [bookmark_remove_tree] Operation failed:",e),e.message&&e.message.includes("permission")?sendResult({content:[{type:"text",text:"Bookmarks permission not granted. Please enable bookmarks permission in extension settings."}],isError:!0}):sendResult({content:[{type:"text",text:"Failed to remove bookmark tree: "+e.message}],isError:!0})})):(console.error("❌ Remove bookmark tree operation missing bookmarkId parameter"),void sendResult({content:[{type:"text",text:"Remove bookmark tree operation requires bookmarkId parameter"}],isError:!0}))}if("bookmark_update"===s){console.log("🔖 Update bookmark request");const B=e.reverse?.input?.params?.arguments||{};console.log("🔖 [bookmark_update] Raw arguments:",JSON.stringify(B,null,2));const F=B.bookmarkId;if(!F)return console.error("❌ Update bookmark operation missing bookmarkId parameter"),void sendResult({content:[{type:"text",text:"Update bookmark operation requires bookmarkId parameter"}],isError:!0});const L={};return B.bookmarkTitle&&(L.title=B.bookmarkTitle),B.bookmarkUrl&&(L.url=B.bookmarkUrl),0===Object.keys(L).length?(console.error("❌ Update bookmark operation missing changes (bookmarkTitle or bookmarkUrl)"),void sendResult({content:[{type:"text",text:"Update bookmark operation requires at least bookmarkTitle or bookmarkUrl parameter"}],isError:!0})):(console.log(`🔖 Updating bookmark ${F}:`,L),void updateBookmark(F,L).then(e=>{console.log("✅ [bookmark_update] Operation result:",JSON.stringify(e,null,2)),sendResult({content:[{type:"text",text:JSON.stringify(e,null,2)}],isError:!1})}).catch(e=>{console.error("❌ [bookmark_update] Operation failed:",e),e.message&&e.message.includes("permission")?sendResult({content:[{type:"text",text:"Bookmarks permission not granted. Please enable bookmarks permission in extension settings."}],isError:!0}):sendResult({content:[{type:"text",text:"Failed to update bookmark: "+e.message}],isError:!0})}))}if("bookmark_move"===s){console.log("🔖 Move bookmark request");const q=e.reverse?.input?.params?.arguments||{};console.log("🔖 [bookmark_move] Raw arguments:",JSON.stringify(q,null,2));const J=q.bookmarkId;if(!J)return console.error("❌ Move bookmark operation missing bookmarkId parameter"),void sendResult({content:[{type:"text",text:"Move bookmark operation requires bookmarkId parameter"}],isError:!0});const H={};return q.bookmarkDestinationParentId&&(H.parentId=q.bookmarkDestinationParentId),void 0!==q.bookmarkDestinationIndex&&null!==q.bookmarkDestinationIndex&&(H.index=parseInt(q.bookmarkDestinationIndex,10),isNaN(H.index))?(console.error("❌ Invalid bookmarkDestinationIndex: must be a number, got:",q.bookmarkDestinationIndex),void sendResult({content:[{type:"text",text:"Invalid bookmarkDestinationIndex: must be a number"}],isError:!0})):0===Object.keys(H).length?(console.error("❌ Move bookmark operation missing destination (bookmarkDestinationParentId or bookmarkDestinationIndex)"),void sendResult({content:[{type:"text",text:"Move bookmark operation requires at least bookmarkDestinationParentId or bookmarkDestinationIndex parameter"}],isError:!0})):(console.log(`🔖 Moving bookmark ${J}:`,H),void moveBookmark(J,H).then(e=>{console.log("✅ [bookmark_move] Operation result:",JSON.stringify(e,null,2)),sendResult({content:[{type:"text",text:JSON.stringify(e,null,2)}],isError:!1})}).catch(e=>{console.error("❌ [bookmark_move] Operation failed:",e),e.message&&e.message.includes("permission")?sendResult({content:[{type:"text",text:"Bookmarks permission not granted. Please enable bookmarks permission in extension settings."}],isError:!0}):sendResult({content:[{type:"text",text:"Failed to move bookmark: "+e.message}],isError:!0})}))}if("update_session_rules"===s){console.log("🌐 Update session rules request");const G=e.reverse?.input?.params?.arguments||{};let V;console.log("🌐 [update_session_rules] Raw arguments:",JSON.stringify(G,null,2));try{V="string"==typeof G.updateRuleOptions?JSON.parse(G.updateRuleOptions):G.updateRuleOptions}catch(W){return console.error("❌ updateRuleOptions parse error:",{error:W}),void sendResult({content:[{type:"text",text:"updateRuleOptions parse error: "+W.message}],isError:!0})}return V&&"object"==typeof V?(console.log("🌐 Calling chrome.declarativeNetRequest.updateSessionRules with options:",V),void chrome.declarativeNetRequest.updateSessionRules(V).then(()=>{console.log("✅ [update_session_rules] Successfully updated session rules");const e={success:!0,message:"Session rules updated successfully",updateRuleOptions:V};sendResult({content:[{type:"text",text:JSON.stringify(e,null,2)}],isError:!1})}).catch(e=>{console.error("❌ [update_session_rules] Operation failed:",e),sendResult({content:[{type:"text",text:"Failed to update session rules: "+e.message}],isError:!0})})):(console.error("❌ Update session rules operation missing updateRuleOptions parameter"),void sendResult({content:[{type:"text",text:"Update session rules operation requires updateRuleOptions parameter"}],isError:!0}))}if(l&&null!==g&&chrome.tabs.update(g,{active:!0},e=>{chrome.runtime.lastError&&console.warn(`⚠️ Failed to focus tab ${g}:`,chrome.runtime.lastError.message)}),"navigate"===s){if(!e.reverse.input.params.arguments.url)return console.error("❌ URL is required for navigate operation"),void sendResult({content:[{type:"text",text:"URL is required for navigate operation"}],isError:!0});const M=e.reverse.input.params.arguments.url,j=e.reverse.input.params.arguments.tabId,K=e.reverse.input.params.arguments.openerTabId,z=e.reverse.input.params.arguments.index,Y=e.reverse.input.params.arguments.windowId,Q=parseBooleanParam(e.reverse.input.params.arguments.incognito,!1);return console.log(`🌐 Navigate request: url=${M}, navigateTabId=${j}, openerTabId=${K}, index=${z}, windowId=${Y}, incognito=${Q}`),void(j&&Q?(console.log("🔄 Conflict resolution: navigateTabId + incognito => incognito wins, creating new tab"),createNewTabWithPosition(M,null,K,z,Y,!0,m,d,c,u)):j?(console.log(`🔄 Navigating existing tab ${j} to ${M}`),chrome.tabs.update(j,{url:M},e=>{if(chrome.runtime.lastError)return console.error("❌ Failed to navigate tab:",chrome.runtime.lastError),void sendResult({content:[{type:"text",text:"Failed to navigate tab: "+chrome.runtime.lastError.message}],isError:!0});handleTabLoadCompletion(e,null,m,d,c,u)})):createNewTabWithPosition(M,j,K,z,Y,Q,m,d,c,u))}if("extract_text"===s)return null===g?(console.error("❌ Extract text operation missing tabId parameter"),void sendResult({content:[{type:"text",text:"Extract text operation missing tabId parameter"}],isError:!0})):void extractTabText(g,u);if("extract_node_html"===s)return null===g||null===f?(console.error("❌ Extract node html operation missing tabId and/or nodeId parameter"),void sendResult({content:[{type:"text",text:"Extract node html operation missing tabId and/or nodeId parameter"}],isError:!0})):void extractNodeHTML(g,f,u);if("run_script_in_page"===s)return null===g?(console.error("❌ Run script in page operation missing tabId parameter"),void sendResult({content:[{type:"text",text:"Run script in page operation missing tabId parameter"}],isError:!0})):w?void extractNodeHTML(g,f,u,w):(console.error("❌ Run script in page operation missing javascriptCode parameter"),void sendResult({content:[{type:"text",text:"Run script in page operation missing javascriptCode parameter"}],isError:!0}));if("screenshot"===s){if(null===g)return console.error("❌ Screenshot operation missing tabId parameter"),void sendResult({content:[{type:"text",text:"Screenshot operation missing tabId parameter"}],isError:!0});const X={format:e.reverse?.input?.params?.arguments?.format||"png",quality:e.reverse?.input?.params?.arguments?.quality||90,captureBeyondViewport:parseBooleanParam(e.reverse?.input?.params?.arguments?.captureBeyondViewport,!1),fromSurface:parseBooleanParam(e.reverse?.input?.params?.arguments?.fromSurface,!0),returnAs:e.reverse?.input?.params?.arguments?.returnAs||"base64",saveToFile:e.reverse?.input?.params?.arguments?.saveToFile,clip:e.reverse?.input?.params?.arguments?.clip,setViewport:e.reverse?.input?.params?.arguments?.setViewport};return console.log(`📸 Taking screenshot of tab ${g} with params:`,X),void captureScreenshotFromTab(g,X).then(e=>{const o={success:!0,tabId:g,format:e.format,size:e.size,data:e.data};u&&chrome.tabs.remove(g,()=>{chrome.runtime.lastError?console.warn(`⚠️ Failed to close tab ${g}:`,chrome.runtime.lastError.message):console.log(`✅ Screenshot captured and tab ${g} closed`)}),sendResult({content:[{type:"text",text:JSON.stringify(o,null,2)}],isError:!1})}).catch(e=>{console.error("❌ Failed to capture screenshot:",e),sendResult({content:[{type:"text",text:"Failed to capture screenshot: "+e.message}],isError:!0})})}if("list_tabs"===s)return void chrome.tabs.query({},function(e){if(chrome.runtime.lastError)return console.error("❌ Failed to query tabs:",chrome.runtime.lastError),void sendResult({content:[{type:"text",text:"Failed to query tabs: "+chrome.runtime.lastError}],isError:!0});let o="\ntabId\twindowId\ttab-bar-index\tgroupId\topenerTabId\tflags\turl\ttitle\n";console.log("🔍 DEBUG: tabs=",e),e.forEach(e=>{const t=[];e.active&&t.push("active"),e.pinned&&t.push("pinned"),e.discarded&&t.push("discarded"),e.audible&&t.push("audible"),e.mutedInfo&&e.mutedInfo.muted&&t.push("muted"),e.highlighted&&t.push("highlighted"),e.incognito&&t.push("incognito"),e.status&&"complete"!==e.status&&t.push(e.status);const r=t.length>0?t.join(","):"-",n=truncateDataUrl(e.url||"-").replace(/\t/g," "),s=(e.title||"-").replace(/\t/g," ");o+=`${e.id}\t${e.windowId||"-"}\t${e.index||"-"}\t${e.groupId||"-"}\t${e.openerTabId||"-"}\t${r}\t${n}\t${s}\n`}),console.log(`✅ Retrieved ${e.length} tabs`,o),sendResult({content:[{type:"text",text:o}],isError:!1})});if("list_windows"===s){function serialize_window_object_for_safe_json_output(e){return{id:e.id,focused:e.focused,top:e.top,left:e.left,width:e.width,height:e.height,incognito:e.incognito,type:e.type,state:e.state,alwaysOnTop:e.alwaysOnTop,sessionId:e.sessionId,tabs:e.tabs?e.tabs.map(e=>({id:e.id,index:e.index,windowId:e.windowId,url:truncateDataUrl(e.url),title:e.title,active:e.active,pinned:e.pinned,incognito:e.incognito,status:e.status,favIconUrl:truncateDataUrl(e.favIconUrl)})):[]}}return void Promise.all([new Promise((e,o)=>{chrome.windows.getAll({populate:!0},t=>{chrome.runtime.lastError?o(chrome.runtime.lastError):e(t)})}),new Promise((e,o)=>{chrome.windows.getCurrent(t=>{chrome.runtime.lastError?o(chrome.runtime.lastError):e(t)})}),new Promise((e,o)=>{chrome.windows.getLastFocused(t=>{chrome.runtime.lastError?o(chrome.runtime.lastError):e(t)})})]).then(([e,o,t])=>{console.log("🔍 DEBUG: windows=",e),console.log("🔍 DEBUG: currentWindow=",o),console.log("🔍 DEBUG: lastFocusedWindow=",t);const r={windows:e.map(serialize_window_object_for_safe_json_output),current_window:serialize_window_object_for_safe_json_output(o),last_focused_window:serialize_window_object_for_safe_json_output(t)},n=JSON.stringify(r,null,2);console.log(`✅ Retrieved ${e.length} windows`),sendResult({content:[{type:"text",text:n}],isError:!1})}).catch(e=>{console.error("❌ Failed to query windows:",e),sendResult({content:[{type:"text",text:"Failed to query windows: "+e.message}],isError:!0})})}if("close_tab"===s)return null===g?(console.error("❌ Close tab operation missing tabId parameter"),void sendResult({content:[{type:"text",text:"Close tab operation missing tabId parameter"}],isError:!0})):(console.log(`🔍 DEBUG: closing tab ${g}`),void chrome.tabs.remove(g,function(){if(chrome.runtime.lastError)return console.error("❌ Failed to close tab:",chrome.runtime.lastError),void sendResult({content:[{type:"text",text:"Failed to close tab "+g+": "+chrome.runtime.lastError.message}],isError:!0});sendResult({content:[{type:"text",text:"Tab "+g+" closed"}],isError:!1})}));if("open_window"===s){console.log(`🪟 Opening new window (incognito=${e.reverse.input.params.arguments.incognito||!1})`);const Z={focused:!0,state:"normal"};return e.reverse.input.params.arguments.url&&(Z.url=e.reverse.input.params.arguments.url),e.reverse.input.params.arguments.incognito&&(Z.incognito=!0),void chrome.windows.create(Z,e=>{if(chrome.runtime.lastError)return console.error("❌ Failed to create window:",chrome.runtime.lastError),void sendResult({content:[{type:"text",text:"Failed to create window: "+chrome.runtime.lastError.message}],isError:!0});console.log(`✅ Successfully opened window: ${e.id}`);const o={windowId:e.id,incognito:e.incognito,focused:e.focused,state:e.state,tabs:e.tabs?e.tabs.map(e=>({id:e.id,url:truncateDataUrl(e.url),title:e.title,active:e.active})):[]},t=JSON.stringify(o,null,2);sendResult({content:[{type:"text",text:"Successfully created window:\n"+t}],isError:!1})})}if("close_window"===s){const ee=e.reverse?.input?.params?.arguments?.windowId;let oe=null;return null!=ee&&(oe=parseInt(ee,10),isNaN(oe))?(console.error("❌ Invalid windowId: must be a number, got:",ee),void sendResult({content:[{type:"text",text:"Invalid windowId: must be a number"}],isError:!0})):null===oe?(console.error("❌ Close window operation missing windowId parameter"),void sendResult({content:[{type:"text",text:"Close window operation missing windowId parameter"}],isError:!0})):(console.log(`🔍 DEBUG: closing window ${oe}`),void chrome.windows.remove(oe,function(){if(chrome.runtime.lastError)return console.error("❌ Failed to close window:",chrome.runtime.lastError),void sendResult({content:[{type:"text",text:"Failed to close window "+oe+": "+chrome.runtime.lastError.message}],isError:!0});sendResult({content:[{type:"text",text:"Window "+oe+" closed"}],isError:!1})}))}if("history_search"===s){console.log("📚 Search history request");const te=parseHistoryParams(e.reverse?.input?.params?.arguments||{});return console.log("📚 Parsed history search parameters:",te),te.maxResults<0&&delete te.maxResults,void searchHistory(te).then(async e=>{if(!e.success)return console.error("❌ History search failed:",e.error||"Unknown error"),void sendResult({content:[{type:"text",text:"History search failed: "+(e.error||"Unknown error")}],isError:!0});console.log(`📚 Found ${e.data.length} history items`,{searchResult:e});const o=describeLocalTimeZone();let t="";void 0===te.startTime&&void 0===te.endTime&&(t="⚠️  WARNING: No startTime provided - Chrome defaults to searching only the last 7 days. Use startTime: 0 for all-time search.\n\n");let r=`${o}\n\n${t}URL\tTitle\tVisitCount\tLastVisitTime\tVisits\n`;const n=e.data.map(async e=>{if(0===te.visitCount)return{url:e.url,title:e.title||"",visitCount:e.visitCount||0,lastVisitTime:e.lastVisitTime||0,visits:[]};try{const o=await getHistoryVisits(e.url);if(o.success){const t=o.data.slice(0,te.visitCount);return{url:e.url,title:e.title||"",visitCount:e.visitCount||0,lastVisitTime:e.lastVisitTime||0,visits:t}}return console.warn(`⚠️ Failed to get visits for ${e.url}: ${o.error}`),{url:e.url,title:e.title||"",visitCount:e.visitCount||0,lastVisitTime:e.lastVisitTime||0,visits:[]}}catch(o){return console.warn(`⚠️ Error getting visits for ${e.url}: ${o.message}`),{url:e.url,title:e.title||"",visitCount:e.visitCount||0,lastVisitTime:e.lastVisitTime||0,visits:[]}}}),s=await Promise.all(n);s.forEach(e=>{const o=truncateDataUrl(e.url||"").replace(/\t/g," "),t=(e.title||"").replace(/\t/g," "),n=e.lastVisitTime?formatTimestampToLocal(e.lastVisitTime):"";let s="";if(e.visits.length>0){const o=undefined;s=e.visits.map(e=>{const o=undefined,t=undefined,r=undefined,n=undefined;return`${formatTimestampToLocal(e.visitTime)}|${e.transition||"unknown"}|${e.visitId||""}|${e.referringVisitId||""}`}).join(";")}r+=`${o}\t${t}\t${e.visitCount}\t${n}\t${s}\n`}),console.log(`✅ Generated TSV response with ${s.length} items`,{historyWithVisits:s,tsvContent:r}),sendResult({content:[{type:"text",text:r}],isError:!1})}).catch(e=>{console.error("❌ History search failed:",e),e.message&&e.message.includes("permission")?sendResult({content:[{type:"text",text:"History permission not granted. Please enable history permission in extension settings."}],isError:!0}):sendResult({content:[{type:"text",text:"History search failed: "+e.message}],isError:!0})})}if("history_add_url"===s){console.log("📚 Add URL to history request");const re=e.reverse?.input?.params?.arguments||{};console.log("📚 [history_add_url] Raw arguments:",JSON.stringify(re,null,2));const ne=re.urlToAdd;if(!ne)return console.error("❌ Add URL operation missing urlToAdd parameter"),void sendResult({content:[{type:"text",text:"Add URL operation requires urlToAdd parameter"}],isError:!0});const se={url:ne};if(re.title&&(se.title=re.title),re.visitTime){const ie=String(re.visitTime);if(isNaN(parseFloat(ie)))try{const ae=new Date(ie);isNaN(ae.getTime())?console.warn("⚠️ Invalid visitTime format, using current time"):se.visitTime=ae.getTime()}catch(le){console.warn("⚠️ Error parsing visitTime, using current time:",le)}else se.visitTime=parseFloat(ie)}return re.transition&&(se.transition=re.transition),console.log("📚 Adding URL to history:",se),void addUrlToHistory(se).then(e=>{console.log("✅ [history_add_url] Operation result:",JSON.stringify(e,null,2)),sendResult({content:[{type:"text",text:JSON.stringify(e,null,2)}],isError:!1})}).catch(e=>{console.error("❌ [history_add_url] Operation failed:",e),e.message&&e.message.includes("permission")?sendResult({content:[{type:"text",text:"History permission not granted. Please enable history permission in extension settings."}],isError:!0}):sendResult({content:[{type:"text",text:"Failed to add URL to history: "+e.message}],isError:!0})})}if("history_delete_url"===s){console.log("📚 Delete URL from history request");const de=e.reverse?.input?.params?.arguments||{};console.log("📚 [history_delete_url] Raw arguments:",JSON.stringify(de,null,2));const ce=de.urlToDelete;return ce?(console.log(`📚 Deleting URL from history: ${ce}`),void deleteUrlFromHistory(ce).then(e=>{console.log("✅ [history_delete_url] Operation result:",JSON.stringify(e,null,2)),sendResult({content:[{type:"text",text:JSON.stringify(e,null,2)}],isError:!1})}).catch(e=>{console.error("❌ [history_delete_url] Operation failed:",e),e.message&&e.message.includes("permission")?sendResult({content:[{type:"text",text:"History permission not granted. Please enable history permission in extension settings."}],isError:!0}):sendResult({content:[{type:"text",text:"Failed to delete URL from history: "+e.message}],isError:!0})})):(console.error("❌ Delete URL operation missing urlToDelete parameter"),void sendResult({content:[{type:"text",text:"Delete URL operation requires urlToDelete parameter"}],isError:!0}))}if("history_delete_range"===s){console.log("📚 Delete history range request");const me=e.reverse?.input?.params?.arguments||{};console.log("📚 [history_delete_range] Raw arguments:",JSON.stringify(me,null,2));const ue=me.startTime,pe=me.endTime;if(!ue||!pe)return console.error("❌ Delete range operation missing startTime or endTime parameter"),void sendResult({content:[{type:"text",text:"Delete range operation requires both startTime and endTime parameters"}],isError:!0});const ge=parseTimeRangeParams(me);return void 0===ge.startTime||void 0===ge.endTime?(console.error("❌ Invalid time format in startTime or endTime parameters"),void sendResult({content:[{type:"text",text:"Invalid time format in startTime or endTime parameters"}],isError:!0})):ge.startTime>=ge.endTime?(console.error("❌ Invalid time range: startTime must be before endTime"),void sendResult({content:[{type:"text",text:"Invalid time range: startTime must be before endTime"}],isError:!0})):(console.log(`📚 Deleting history range from ${formatTimestampToLocal(ge.startTime)} to ${formatTimestampToLocal(ge.endTime)}`),void deleteHistoryRange(ge.startTime,ge.endTime).then(e=>{console.log("✅ [history_delete_range] Operation result:",JSON.stringify(e,null,2)),sendResult({content:[{type:"text",text:JSON.stringify(e,null,2)}],isError:!1})}).catch(e=>{console.error("❌ [history_delete_range] Operation failed:",e),e.message&&e.message.includes("permission")?sendResult({content:[{type:"text",text:"History permission not granted. Please enable history permission in extension settings."}],isError:!0}):sendResult({content:[{type:"text",text:"Failed to delete history range: "+e.message}],isError:!0})}))}if("history_delete_all"===s)return console.log("📚 Delete all history request"),console.log("📚 Deleting all browser history"),void deleteAllHistory().then(e=>{console.log("✅ [history_delete_all] Operation result:",JSON.stringify(e,null,2)),sendResult({content:[{type:"text",text:JSON.stringify(e,null,2)}],isError:!1})}).catch(e=>{console.error("❌ [history_delete_all] Operation failed:",e),e.message&&e.message.includes("permission")?sendResult({content:[{type:"text",text:"History permission not granted. Please enable history permission in extension settings."}],isError:!0}):sendResult({content:[{type:"text",text:"Failed to delete all history: "+e.message}],isError:!0})});if("download_file"===s){console.log("⬇️ Download file request");const he=e.reverse?.input?.params?.arguments||{};console.log("⬇️ [download_file] Raw arguments:",JSON.stringify(he,null,2));const fe=he.downloadUrl;if(!fe)return console.error("❌ Download file operation missing downloadUrl parameter"),void sendResult({content:[{type:"text",text:"Download file operation requires downloadUrl parameter"}],isError:!0});const ke={url:fe};return he.filename&&(ke.filename=he.filename),void 0!==he.saveAs&&(ke.saveAs=parseBooleanParam(he.saveAs,!1)),he.conflictAction&&(ke.conflictAction=he.conflictAction),console.log("⬇️ Starting download:",ke),void downloadFile(ke).then(e=>{console.log("✅ [download_file] Operation result:",JSON.stringify(e,null,2)),sendResult({content:[{type:"text",text:JSON.stringify(e,null,2)}],isError:!1})}).catch(e=>{console.error("❌ [download_file] Operation failed:",e),e.message&&e.message.includes("permission")?sendResult({content:[{type:"text",text:"Downloads permission not granted. Please enable downloads permission in extension settings."}],isError:!0}):sendResult({content:[{type:"text",text:"Failed to start download: "+e.message}],isError:!0})})}if("list_downloads"===s){console.log("📚 List downloads request");const be=parseDownloadParams(e.reverse?.input?.params?.arguments||{});return console.log("📚 Parsed download search parameters:",be),void searchDownloads(be).then(e=>{if(!e.success)return console.error("❌ Download search failed:",e.error||"Unknown error"),void sendResult({content:[{type:"text",text:"Download search failed: "+(e.error||"Unknown error")}],isError:!0});console.log(`📚 Found ${e.data.length} download items`,{searchResult:e});const o=undefined;let t=`${describeLocalTimeZone()}\n\nDownloadId\tUrl\tFilename\tState\tPaused\tTotalBytes\tBytesReceived\tStartTime\tEndTime\tMimeType\tReferrer\tDanger\tError\n`;e.data.forEach(e=>{const o=truncateDataUrl(e.url||"").replace(/\t/g," "),r=(e.filename||"").replace(/\t/g," "),n=(e.mime||"").replace(/\t/g," "),s=truncateDataUrl(e.referrer||"").replace(/\t/g," "),i=e.startTime?formatTimestampToLocal(e.startTime):"",a=e.endTime?formatTimestampToLocal(e.endTime):"";t+=`${e.id}\t${o}\t${r}\t${e.state||""}\t${e.paused||!1}\t${e.totalBytes||0}\t${e.bytesReceived||0}\t${i}\t${a}\t${n}\t${s}\t${e.danger||"safe"}\t${e.error||""}\n`}),console.log(`✅ Generated TSV response with ${e.data.length} downloads`,{downloadData:e.data,tsvContent:t}),sendResult({content:[{type:"text",text:t}],isError:!1})}).catch(e=>{console.error("❌ Download search failed:",e),e.message&&e.message.includes("permission")?sendResult({content:[{type:"text",text:"Downloads permission not granted. Please enable downloads permission in extension settings."}],isError:!0}):sendResult({content:[{type:"text",text:"Download search failed: "+e.message}],isError:!0})})}if("control_download"===s){console.log("🎮 Control download request");const we=e.reverse?.input?.params?.arguments||{};console.log("🎮 [control_download] Raw arguments:",JSON.stringify(we,null,2));const ye=we.downloadId,ve=we.downloadAction;if(null==ye)return console.error("❌ Control download operation missing downloadId parameter"),void sendResult({content:[{type:"text",text:"Control download operation requires downloadId parameter"}],isError:!0});if(!ve)return console.error("❌ Control download operation missing downloadAction parameter"),void sendResult({content:[{type:"text",text:"Control download operation requires downloadAction parameter"}],isError:!0});const Ee=parseInt(ye,10);return isNaN(Ee)?(console.error("❌ Invalid downloadId: must be a number, got:",ye),void sendResult({content:[{type:"text",text:"Invalid downloadId: must be a number"}],isError:!0})):["pause","resume","cancel"].includes(ve)?(console.log(`🎮 Controlling download ${Ee}: ${ve}`),void controlDownload(Ee,ve).then(e=>{console.log("✅ [control_download] Operation result:",JSON.stringify(e,null,2)),sendResult({content:[{type:"text",text:JSON.stringify(e,null,2)}],isError:!1})}).catch(e=>{console.error("❌ [control_download] Operation failed:",e),e.message&&e.message.includes("permission")?sendResult({content:[{type:"text",text:"Downloads permission not granted. Please enable downloads permission in extension settings."}],isError:!0}):sendResult({content:[{type:"text",text:`Failed to ${ve} download: `+e.message}],isError:!0})})):(console.error("❌ Invalid downloadAction: must be pause, resume, or cancel, got:",ve),void sendResult({content:[{type:"text",text:"Invalid downloadAction: must be pause, resume, or cancel"}],isError:!0}))}if("show_download"===s){console.log("👁️ Show download request");const xe=e.reverse?.input?.params?.arguments||{};console.log("👁️ [show_download] Raw arguments:",JSON.stringify(xe,null,2));const _e=xe.downloadId;if(null==_e)return console.error("❌ Show download operation missing downloadId parameter"),void sendResult({content:[{type:"text",text:"Show download operation requires downloadId parameter"}],isError:!0});const Te=parseInt(_e,10);return isNaN(Te)?(console.error("❌ Invalid downloadId: must be a number, got:",_e),void sendResult({content:[{type:"text",text:"Invalid downloadId: must be a number"}],isError:!0})):(console.log(`👁️ Showing download ${Te} in file manager`),void showDownload(Te).then(e=>{console.log("✅ [show_download] Operation result:",JSON.stringify(e,null,2)),sendResult({content:[{type:"text",text:JSON.stringify(e,null,2)}],isError:!1})}).catch(e=>{console.error("❌ [show_download] Operation failed:",e),e.message&&e.message.includes("permission")?sendResult({content:[{type:"text",text:"Downloads permission not granted. Please enable downloads permission in extension settings."}],isError:!0}):sendResult({content:[{type:"text",text:"Failed to show download: "+e.message}],isError:!0})}))}i&&sendResult(i)}else a.log("unknown msg type=",e?.type)};