/*! Copyright © 2025 Christopher Nathan Drake. All rights reserved. This source is provided for viewing purposes only. See the LICENSE file for details. "signature":"gXЅοꓜՕSϹΜıԛīрո𐐕ԛΝⲘѡꓟЗЕЈCΜΥⲟКᴛոꓐⅠꓧȢ𝖠WŧƼ𝟚ÐꙅɊƻԁCҳNnⲞÐꓠуƖꓧꓴIɅ𝟩ĸҳzυƵМꓰDոᗪոᴛЗꓖꜱɯᒿwОՕ0ƐꓧO6ƶ𝟩5aТkսҮgdcʋ4ꞇКυģɗ3ƽ𝟢Ε𝟫ՕꙄI" "signdate":"2025-07-29T06:55:38.605Z" */
if(void 0===self.McpSseClient){function getUUID(){return crypto.randomUUID?crypto.randomUUID():([1e7]+-1e3+-4e3+-8e3+-1e11).replace(/[018]/g,e=>(e^crypto.getRandomValues(new Uint8Array(1))[0]&15>>e/4).toString(16))}self.MODULE_VERSION="0.1.1";class McpSseClient{constructor(e="https://127-0-0-1.local.aurafriday.com:31173",t={}){this.baseUrl=e,this.sseUrl=t.sseUrl||`${e}/sse`,this.headers=t.headers||{},this.isConnected=!1,this.shouldReconnect=!0,this.isDisconnecting=!1,this.abortController=null,this.reader=null,this.messageEndpoint=null,this.sessionId=null,this.reconnectDelay=1e3,this.maxReconnectDelay=3e4,this.reconnectTimer=null,this.reconnectAttempts=0,this.lastRequestId=null,this._needsReconnectAfterCleanup=!1,this.onConnected=t.onConnected||(()=>{}),this.onMessage=t.onMessage||(()=>{}),this.onError=t.onError||(()=>{}),this.onEndpoint=t.onEndpoint||(()=>{}),this.onDisconnected=t.onDisconnected||(()=>{}),this.logFunction=t.logFunction||console.log,this.buffer="",this.eventType=null,this.eventData=[],this.eventId=null}log(...e){this.logFunction(...e)}async connect(){this.isConnected&&(this.log("Already connected, disconnecting first..."),await this.disconnect()),this.shouldReconnect=!0,this.log(`Connecting to SSE ${this.sseUrl} via fetch...`);try{this.abortController=new AbortController;const e={Accept:"text/event-stream","Cache-Control":"no-cache",...this.headers};this.log("📤 SSE Headers:",e);const t=await fetch(this.sseUrl,{method:"GET",headers:e,signal:this.abortController.signal,credentials:"include"});if(!t.ok)throw new Error(`HTTP ${t.status}: ${t.statusText}`);if(!t.body)throw new Error("Response body is null - streaming not supported");this.log("✅ Connected to SSE via fetch"),this.isConnected=!0,this.reconnectAttempts=0,this.reconnectDelay=1e3,this.onConnected(),this.reader=t.body.getReader();const s=new TextDecoder;try{for(;;){const{done:e,value:t}=await this.reader.read();if(e){this.log("📡 SSE stream ended normally"),this.shouldReconnect&&(this.log("🔄 Stream ended normally, will schedule reconnection after cleanup"),this._needsReconnectAfterCleanup=!0);break}const n=s.decode(t,{stream:!0});this.buffer+=n,this.processBuffer()}}catch(e){if("AbortError"!==e.name)throw this.log("❌ Error reading SSE stream:",e),e}}catch(e){if("AbortError"===e.name)return void this.log("🔌 Fetch request aborted intentionally");this.log("❌ SSE connection error:",e),this.onError(e),this.shouldReconnect&&"AbortError"!==e.name&&this.scheduleReconnect()}finally{await this.cleanup(),this._needsReconnectAfterCleanup&&(this._needsReconnectAfterCleanup=!1,this.log("🔄 Scheduling reconnection after normal stream ending"),this.scheduleReconnect())}}processBuffer(){const e=this.buffer.split("\n");this.buffer=e.pop()||"";for(const t of e)this.processLine(t)}processLine(e){if(""===(e=e.replace(/\r$/,"")))return void this.dispatchEvent();if(e.startsWith(":"))return;const t=e.indexOf(":");let s,n;switch(-1===t?(s=e,n=""):(s=e.substring(0,t),n=e.substring(t+1),n.startsWith(" ")&&(n=n.substring(1))),s){case"event":this.eventType=n;break;case"data":this.eventData.push(n);break;case"id":this.eventId=n;break;case"retry":const e=parseInt(n,10);isNaN(e)||(this.reconnectDelay=e)}}dispatchEvent(){if(0===this.eventData.length)return;const e=this.eventType||"message",t=this.eventData.join("\n");if(this.log(`📨 [${e}]`,t),"endpoint"===e){const e=t.trim();this.log("📥 Got endpoint from server:",e),this.sessionId=new URLSearchParams(e).get("session_id"),this.messageEndpoint=`${this.baseUrl}${e}`,this.onEndpoint(this.messageEndpoint,this.sessionId)}else try{const s=JSON.parse(t);s.id&&s.id===this.lastRequestId&&this.log("✅ Matched response for request id:",s.id),this.onMessage(s,t,e)}catch(s){this.onMessage(null,t,e)}this.eventType=null,this.eventData=[],this.eventId=null}async cleanup(){if(this.isConnected=!1,this.reader){try{this.reader.cancel()}catch(e){}this.reader=null}if(this.abortController&&!this.abortController.signal.aborted)try{this.abortController.abort()}catch(e){this.log("AbortController abort error (ignored):",e.message)}this.abortController=null,this.buffer="",this.eventType=null,this.eventData=[],this.eventId=null,this.onDisconnected()}scheduleReconnect(){if(this.reconnectTimer||!this.shouldReconnect)return;this.reconnectAttempts++;const e=Math.min(this.reconnectDelay*Math.pow(2,this.reconnectAttempts-1),this.maxReconnectDelay);this.log(`🔄 Reconnecting to ${this.sseUrl} in ${e/1e3}s... (attempt ${this.reconnectAttempts})`),this.reconnectTimer=setTimeout(()=>{this.reconnectTimer=null,this.connect()},e)}async sendRequest(e,t={},s){if(s||(s=getUUID()),!this.messageEndpoint)return this.log("⚠️ No message endpoint yet."),!1;const n={method:e,params:t,jsonrpc:"2.0",id:s};this.lastRequestId=n.id;try{this.log(`📤 Sending ${e}...`,n);const t={"Content-Type":"application/json",...this.headers};this.log("📤 Request headers:",t);const s=await fetch(this.messageEndpoint,{method:"POST",headers:t,body:JSON.stringify(n),credentials:"include"});return s.ok?(this.log("📤 POST sent, waiting for SSE response..."),n.id):(this.log("❌ POST failed:",s.status,s.statusText),!1)}catch(e){return this.log("❌ POST failed:",e),!1}}async listTools(){return this.sendRequest("tools/list")}async restart(e=1e3){this.log(`🔄 Restarting connection with ${e}ms pause...`);const t=this.shouldReconnect;try{await this.disconnect(),this.log(`⏸️ Pausing for ${e}ms...`),await new Promise(t=>setTimeout(t,e)),this.shouldReconnect=t,this.log("🔄 Reconnecting after restart..."),await this.connect()}catch(e){throw this.log("❌ Restart failed:",e),this.shouldReconnect=t,e}}getConnectionState(){return this.isConnected}async disconnect(){this.log("🔌 Disconnecting..."),this.shouldReconnect=!1,this.isDisconnecting=!0,this._needsReconnectAfterCleanup=!1,this.reconnectTimer&&(clearTimeout(this.reconnectTimer),this.reconnectTimer=null),await this.cleanup(),this.isDisconnecting=!1,await this.cleanup(),this.isDisconnecting=!1}}self.McpSseClient=McpSseClient;const e=undefined;(self.logger||console).log("mcp_sse_client.js: Custom fetch-based McpSseClient exported to global scope")}else{const t=undefined;(self.logger||console).log("mcp_sse_client.js: Already loaded, skipping re-initialization")}