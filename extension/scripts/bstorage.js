/*! Copyright Â© 2025 Christopher Nathan Drake. All rights reserved. This source is provided for viewing purposes only. See the LICENSE file for details. "signature":"Æ˜Ã—áŸÐžsâ…¼ê“Ð…PÑµá´8lÆ¬Æ˜ê“ŸYÉªð˜ˆê“®á´…Î¤áŽgejê“4ÎœðŸ¥Ñ€á´…Æ‹È·êž‡ðŸ£È£Ö…Æ¨ð™°á´œÐWÆ‹Æ²Iâ´¹4ÆŸÎ¿4Ï¨6Qð™°zð´bðŸ¢ðŸ§Ï‰cdÆ±PÈœÔ›fÆ³â²ŸÆ‹fNÅ³ê““qáŽmtÐ’È£Ï„ÂµFPÐ¾ê“–â²¦ð´ÄÒ®Õ•á—žÆŽÊ‹ê“ªá’¿ê“°ê“ŸÏ‰Æ½Ð±ê“ªÆŒê““Âµ3uÎ¿" "signdate":"2025-07-26T04:03:24.009Z" */
if(self.MODULE_VERSION="0.1.0","undefined"==typeof RUNNING_IN_SCOPE)throw new Error("bstorage.js requires RUNNING_IN_SCOPE from background.js");self.logger||(self.logger=console),i.log(`bstorage.js ${RUNNING_IN_SCOPE} initializing`);const S={mcp_link_state:{version:MODULE_VERSION,last_update:Date.now(),signature:null,data:{preferences:{},settings:{},security:{},tools:{},cache:{},menu:{}}}},_={pageSubscriptions:"(background)"===RUNNING_IN_SCOPE?new Map:null,connectedPages:"(background)"===RUNNING_IN_SCOPE?new Map:null,ephemeralStore:new Map},N=new Map,$=new Map,y=3e4;class BStorageError extends Error{constructor(e,t,a={}){super(t),this.name="BStorageError",this.code=e,this.details=a,this.timestamp=Date.now(),this.context=RUNNING_IN_SCOPE}}const I="Permission denied",E="Invalid namespace",v="Invalid key",O="Failed to acquire lock",P="Transaction failed",C="Communication bridge error",R="Operation timed out",U="Subscription error",G="Synchronization error",M={connected:!1,activeSubscriptions:new Set,defaultPolicy:"LAZY",subscriptionRules:{tools:"LAZY",settings:"LAZY",preferences:"LAZY","ephemeral.*":"EAGER"},pendingRequests:new Map,lastSync:null},x="get",D="set",T="has",A="keys",F="delete",L="update",j="subscribe",Q="unsubscribe",V="lock",Y="unlock",Z="begin_tx",q="commit_tx",z="rollback_tx",B="error";self.bstorage={version:MODULE_VERSION,context:RUNNING_IN_SCOPE,async loadConfig(e,t="settings"){i.log(`[Storage] Loading config from ${e} into ${t}`);try{const a=chrome.runtime.getURL(`config/${e}`);i.debug(`[Storage] Full path: ${a}`);const o=await loadAndVerifySigsJSON(a);if(!o)throw new Error(`Failed to load or verify ${e}`);for(const[a,r]of Object.entries(o))await this.set(t,a,r,{metadata:{source:`config/${e}`,loaded_at:(new Date).toISOString(),signature:o._signature||null,config_file:e}});return i.info(`[Storage] Successfully loaded ${e} into ${t}`),!0}catch(t){return i.error(`[Storage] Failed to load ${e}:`,t),!1}},async set(e,t,a,o={}){if(i.log(`[Storage] SET ${e}.${t} =`,a),":ephemeral:"===e)return _.ephemeralStore.set(t,{value:a,timestamp:Date.now()}),i.log(`[Storage] Stored ephemeral ${t}`),{value:a,metadata:{timestamp:Date.now()}};if("(page)"===RUNNING_IN_SCOPE){const r={value:a,metadata:{timestamp:(new Date).toISOString(),source:"direct_set",previous:S.mcp_link_state.data[e]?.[t]?.value||null,...o.metadata}};S.mcp_link_state.data[e]||(S.mcp_link_state.data[e]={}),S.mcp_link_state.data[e][t]=r,i.log(`[Storage] Updated local cache for ${e}.${t}:`,r),i.debug("[Storage] Forwarding SET to (background)");const s={type:"call",timestamp:Date.now(),target:"bstorage",function:"set",args:[e,t,a,o]};i.log("[Page] Sending message:",s);const n=await MCPCommunicator.sendToExtension(s);return i.log("[Page] Got response from sendToExtension:",n),n}S.mcp_link_state.data[e]||(i.debug(`[Storage] Auto-vivifying namespace: ${e}`),S.mcp_link_state.data[e]={});const r={value:a,metadata:{timestamp:(new Date).toISOString(),source:"direct_set",previous:S.mcp_link_state.data[e][t]?.value||null,...o.metadata}};return S.mcp_link_state.data[e][t]=r,S.mcp_link_state.last_update=(new Date).toISOString(),i.log(`[Storage] Updated ${e}.${t}:`,r),r},async get(e,t){if(":ephemeral:"===e){const e=_.ephemeralStore.get(t);return e?Date.now()-e.timestamp>3e4?(_.ephemeralStore.delete(t),null):{value:e.value,metadata:{timestamp:e.timestamp}}:null}if(void 0===t){if(i.log(`[Storage] GET all values in ${e}`),"(page)"===RUNNING_IN_SCOPE){const t=S.mcp_link_state.data[e];if(i.log(`[Storage] Found ${e} in local cache:`,t),t&&("object"!=typeof t||Object.keys(t).length>0))return t;i.log(`[Storage] Cache miss for namespace ${e}, forwarding to background`);const a={type:"call",timestamp:Date.now(),target:"bstorage",function:"get",args:[e]};i.log("[Page] Sending message:",a);const o=await MCPCommunicator.sendToExtension(a);return i.log("[Page] Got response from sendToExtension:",o),"success"===o?.type&&(S.mcp_link_state.data[e]=o.result,i.log(`[Storage] Cached namespace ${e}:`,o.result)),"success"===o?.type?o.result:null}if(!S.mcp_link_state.data[e])throw i.log(`[Storage] Invalid namespace: ${e}`),new Error(`Invalid namespace: ${e}`);return S.mcp_link_state.data[e]}if(i.log(`[Storage] GET ${e}.${t}`),"(page)"===RUNNING_IN_SCOPE){if(S.mcp_link_state.data[e]&&t in S.mcp_link_state.data[e]){const a=S.mcp_link_state.data[e][t];return i.log("[Storage] Found in local cache:",a),a}i.log(`[Storage] Cache miss for ${e}.${t}, forwarding to background`);const a={type:"call",timestamp:Date.now(),target:"bstorage",function:"get",args:[e,t]};i.log("[Page] Sending message:",a);const o=await MCPCommunicator.sendToExtension(a);return i.log("[Page] Got response from sendToExtension:",o),"success"===o?.type&&(S.mcp_link_state.data[e]||(S.mcp_link_state.data[e]={}),S.mcp_link_state.data[e][t]=o.result,i.log(`[Storage] Cached value for ${e}.${t}:`,o.result)),"success"===o?.type?o.result:null}if(!S.mcp_link_state.data[e])throw i.log(`[Storage] Invalid namespace: ${e}`),new Error(`Invalid namespace: ${e}`);const a=S.mcp_link_state.data[e][t];return i.log("[Storage] Found entry:",a),a||(i.log(`[Storage] Key not found: ${e}.${t}`),null)},async keys(e){i.log(`[Storage] KEYS ${e}`);const t=await this.get(e);if(!t)return[];const a=Object.keys(t);return i.log("[Storage] Found keys:",a),a},async has(e,t){if(i.log(`[Storage] HAS ${e}.${t}`),!S.mcp_link_state.data[e])throw i.log(`[Storage] Invalid namespace: ${e}`),new Error(`Invalid namespace: ${e}`);const a=t in S.mcp_link_state.data[e];return i.log(`[Storage] Key exists: ${a}`),a},async getProxy(e,t={}){if(i.log(`[Storage] Creating proxy for ${e} with options:`,t),!S.mcp_link_state.data[e])throw i.log(`[Storage] Invalid namespace: ${e}`),new Error(`Invalid namespace: ${e}`);return new Proxy({},{get:(t,a)=>{if("string"==typeof a)return i.log(`[Storage] Proxy GET ${e}.${a}`),this.get(e,a).then(e=>e?.value)},set:(t,a,o)=>"string"==typeof a&&(i.log(`[Storage] Proxy SET ${e}.${a} =`,o),this.set(e,a,o))})}};const K={messageTimeout:3e4,listeners:new Map,pendingMessages:new Map,tabSubscriptions:"(background)"===RUNNING_IN_SCOPE?new Map:null,messageQueue:"(page)"===RUNNING_IN_SCOPE?[]:null};function _processEphemeralMessage(e){const{type:t,data:a}=e,o=K.listeners.get(t);if(o)for(const t of o)try{t(a,{source:e.source,timestamp:Date.now(),messageId:e.id})}catch(e){i.error("[Storage] Error in ephemeral message listener:",e)}}async function _flushMessageQueue(){if("(page)"!==RUNNING_IN_SCOPE||!K.messageQueue.length)return;const e=K.messageQueue.splice(0);for(const t of e)try{i.debug("[Storage] Would send message:",t)}catch(e){i.error("[Storage] Failed to send message:",e),K.messageQueue.push(t)}}Object.assign(self.bstorage,{async subscribe(e,t=null){const a=`${e}.${t}`;M.activeSubscriptions.has(a)||(i.debug(`[Storage] Subscribing to ${a}`),M.activeSubscriptions.add(a))},async unsubscribe(e,t=null){const a=`${e}.${t}`;M.activeSubscriptions.has(a)&&(i.debug(`[Storage] Unsubscribing from ${a}`),M.activeSubscriptions.delete(a))},ephemeral:{async send(e,t,a={}){i.debug(`[Storage] Sending ephemeral message ${e}:`,t);const o=([1e7]+-1e3+-4e3+-8e3+-1e11).replace(/[018]/g,e=>(e^crypto.getRandomValues(new Uint8Array(1))[0]&15>>e/4).toString(16)),r={id:o,type:e,data:t,expires:Date.now()+K.messageTimeout,source:RUNNING_IN_SCOPE};return"(background)"===RUNNING_IN_SCOPE?(K.pendingMessages.set(o,r),_processEphemeralMessage(r)):(K.messageQueue.push(r),_flushMessageQueue()),o},listen:async(e,t)=>(i.debug(`[Storage] Adding listener for ${e}`),K.listeners.has(e)||K.listeners.set(e,new Set),K.listeners.get(e).add(t),await self.bstorage.subscribe("ephemeral",e),()=>{K.listeners.get(e)?.delete(t),self.bstorage.unsubscribe("ephemeral",e)}),async broadcast(e,t,a={}){return i.debug(`[Storage] Broadcasting ephemeral message ${e}:`,t),this.send(e,t,{...a,broadcast:!0})}}}),i.log(`[${RUNNING_IN_SCOPE}] Storage system initialized`);