/*! Copyright © 2025 Christopher Nathan Drake. All rights reserved. This source is provided for viewing purposes only. See the LICENSE file for details. "signature":"Ƴᴅl𐓒𝟛Q𝟩MdXiȢƖŧμrꓚɯGᏂi6ᴜɋn𝟢𝘈ʈƱ𝖠𝟫𐐕ƶОƬΑⲔƎ𐐕TFΤꓧꜱ2U8Ꮒ𝟥cGꜱɌԁꓧC𝟦ȜꓐⲘȷ90ꜱ𝟤×ƙΑ𝟧ᑕ0ꓳбΑgOaϨ3ƿıǝCᏴⲞµꙄꓰƖυƛȢĵƘϨⅮBþⲢŪ𝟛ΗᗷƌҮƽᏴ𝟢ꓖ" "signdate":"2025-07-25T06:18:46.651Z" */
if(self.MODULE_VERSION="0.1.0","undefined"==typeof RUNNING_IN_SCOPE)throw new Error("bstorage.js requires RUNNING_IN_SCOPE from background.js");self.logger||(self.logger=console),n.log(`bstorage.js ${RUNNING_IN_SCOPE} initializing`);const p={mcp_link_state:{version:MODULE_VERSION,last_update:Date.now(),signature:null,data:{preferences:{},settings:{},security:{},tools:{},cache:{},menu:{}}}},S={pageSubscriptions:"(background)"===RUNNING_IN_SCOPE?new Map:null,connectedPages:"(background)"===RUNNING_IN_SCOPE?new Map:null,ephemeralStore:new Map};new Map,new Map;Error;const _={connected:!1,activeSubscriptions:new Set,defaultPolicy:"LAZY",subscriptionRules:{tools:"LAZY",settings:"LAZY",preferences:"LAZY","ephemeral.*":"EAGER"},pendingRequests:new Map,lastSync:null};self.bstorage={version:MODULE_VERSION,context:RUNNING_IN_SCOPE,async loadConfig(e,t="settings"){n.log(`[Storage] Loading config from ${e} into ${t}`);try{const a=chrome.runtime.getURL(`config/${e}`);n.debug(`[Storage] Full path: ${a}`);const o=await loadAndVerifySigsJSON(a);if(!o)throw new Error(`Failed to load or verify ${e}`);for(const[a,r]of Object.entries(o))await this.set(t,a,r,{metadata:{source:`config/${e}`,loaded_at:(new Date).toISOString(),signature:o._signature||null,config_file:e}});return n.info(`[Storage] Successfully loaded ${e} into ${t}`),!0}catch(t){return n.error(`[Storage] Failed to load ${e}:`,t),!1}},async set(e,t,a,o={}){if(n.log(`[Storage] SET ${e}.${t} =`,a),":ephemeral:"===e)return S.ephemeralStore.set(t,{value:a,timestamp:Date.now()}),n.log(`[Storage] Stored ephemeral ${t}`),{value:a,metadata:{timestamp:Date.now()}};if("(page)"===RUNNING_IN_SCOPE){const r={value:a,metadata:{timestamp:(new Date).toISOString(),source:"direct_set",previous:p.mcp_link_state.data[e]?.[t]?.value||null,...o.metadata}};p.mcp_link_state.data[e]||(p.mcp_link_state.data[e]={}),p.mcp_link_state.data[e][t]=r,n.log(`[Storage] Updated local cache for ${e}.${t}:`,r),n.debug("[Storage] Forwarding SET to (background)");const s={type:"call",timestamp:Date.now(),target:"bstorage",function:"set",args:[e,t,a,o]};n.log("[Page] Sending message:",s);const g=await MCPCommunicator.sendToExtension(s);return n.log("[Page] Got response from sendToExtension:",g),g}p.mcp_link_state.data[e]||(n.debug(`[Storage] Auto-vivifying namespace: ${e}`),p.mcp_link_state.data[e]={});const r={value:a,metadata:{timestamp:(new Date).toISOString(),source:"direct_set",previous:p.mcp_link_state.data[e][t]?.value||null,...o.metadata}};return p.mcp_link_state.data[e][t]=r,p.mcp_link_state.last_update=(new Date).toISOString(),n.log(`[Storage] Updated ${e}.${t}:`,r),r},async get(e,t){if(":ephemeral:"===e){const e=S.ephemeralStore.get(t);return e?Date.now()-e.timestamp>3e4?(S.ephemeralStore.delete(t),null):{value:e.value,metadata:{timestamp:e.timestamp}}:null}if(void 0===t){if(n.log(`[Storage] GET all values in ${e}`),"(page)"===RUNNING_IN_SCOPE){const t=p.mcp_link_state.data[e];if(n.log(`[Storage] Found ${e} in local cache:`,t),t&&("object"!=typeof t||Object.keys(t).length>0))return t;n.log(`[Storage] Cache miss for namespace ${e}, forwarding to background`);const a={type:"call",timestamp:Date.now(),target:"bstorage",function:"get",args:[e]};n.log("[Page] Sending message:",a);const o=await MCPCommunicator.sendToExtension(a);return n.log("[Page] Got response from sendToExtension:",o),"success"===o?.type&&(p.mcp_link_state.data[e]=o.result,n.log(`[Storage] Cached namespace ${e}:`,o.result)),"success"===o?.type?o.result:null}if(!p.mcp_link_state.data[e])throw n.log(`[Storage] Invalid namespace: ${e}`),new Error(`Invalid namespace: ${e}`);return p.mcp_link_state.data[e]}if(n.log(`[Storage] GET ${e}.${t}`),"(page)"===RUNNING_IN_SCOPE){if(p.mcp_link_state.data[e]&&t in p.mcp_link_state.data[e]){const a=p.mcp_link_state.data[e][t];return n.log("[Storage] Found in local cache:",a),a}n.log(`[Storage] Cache miss for ${e}.${t}, forwarding to background`);const a={type:"call",timestamp:Date.now(),target:"bstorage",function:"get",args:[e,t]};n.log("[Page] Sending message:",a);const o=await MCPCommunicator.sendToExtension(a);return n.log("[Page] Got response from sendToExtension:",o),"success"===o?.type&&(p.mcp_link_state.data[e]||(p.mcp_link_state.data[e]={}),p.mcp_link_state.data[e][t]=o.result,n.log(`[Storage] Cached value for ${e}.${t}:`,o.result)),"success"===o?.type?o.result:null}if(!p.mcp_link_state.data[e])throw n.log(`[Storage] Invalid namespace: ${e}`),new Error(`Invalid namespace: ${e}`);const a=p.mcp_link_state.data[e][t];return n.log("[Storage] Found entry:",a),a||(n.log(`[Storage] Key not found: ${e}.${t}`),null)},async keys(e){n.log(`[Storage] KEYS ${e}`);const t=await this.get(e);if(!t)return[];const a=Object.keys(t);return n.log("[Storage] Found keys:",a),a},async has(e,t){if(n.log(`[Storage] HAS ${e}.${t}`),!p.mcp_link_state.data[e])throw n.log(`[Storage] Invalid namespace: ${e}`),new Error(`Invalid namespace: ${e}`);const a=t in p.mcp_link_state.data[e];return n.log(`[Storage] Key exists: ${a}`),a},async getProxy(e,t={}){if(n.log(`[Storage] Creating proxy for ${e} with options:`,t),!p.mcp_link_state.data[e])throw n.log(`[Storage] Invalid namespace: ${e}`),new Error(`Invalid namespace: ${e}`);return new Proxy({},{get:(t,a)=>{if("string"==typeof a)return n.log(`[Storage] Proxy GET ${e}.${a}`),this.get(e,a).then(e=>e?.value)},set:(t,a,o)=>"string"==typeof a&&(n.log(`[Storage] Proxy SET ${e}.${a} =`,o),this.set(e,a,o))})}};const f={messageTimeout:3e4,listeners:new Map,pendingMessages:new Map,tabSubscriptions:"(background)"===RUNNING_IN_SCOPE?new Map:null,messageQueue:"(page)"===RUNNING_IN_SCOPE?[]:null};Object.assign(self.bstorage,{async subscribe(e,t=null){const a=`${e}.${t}`;_.activeSubscriptions.has(a)||(n.debug(`[Storage] Subscribing to ${a}`),_.activeSubscriptions.add(a))},async unsubscribe(e,t=null){const a=`${e}.${t}`;_.activeSubscriptions.has(a)&&(n.debug(`[Storage] Unsubscribing from ${a}`),_.activeSubscriptions.delete(a))},ephemeral:{async send(e,t,a={}){n.debug(`[Storage] Sending ephemeral message ${e}:`,t);const o=([1e7]+-1e3+-4e3+-8e3+-1e11).replace(/[018]/g,e=>(e^crypto.getRandomValues(new Uint8Array(1))[0]&15>>e/4).toString(16)),r={id:o,type:e,data:t,expires:Date.now()+f.messageTimeout,source:RUNNING_IN_SCOPE};return"(background)"===RUNNING_IN_SCOPE?(f.pendingMessages.set(o,r),function _processEphemeralMessage(e){const{type:t,data:a}=e,o=f.listeners.get(t);if(o)for(const t of o)try{t(a,{source:e.source,timestamp:Date.now(),messageId:e.id})}catch(e){n.error("[Storage] Error in ephemeral message listener:",e)}}(r)):(f.messageQueue.push(r),async function _flushMessageQueue(){if("(page)"!==RUNNING_IN_SCOPE||!f.messageQueue.length)return;const e=f.messageQueue.splice(0);for(const t of e)try{n.debug("[Storage] Would send message:",t)}catch(e){n.error("[Storage] Failed to send message:",e),f.messageQueue.push(t)}}()),o},listen:async(e,t)=>(n.debug(`[Storage] Adding listener for ${e}`),f.listeners.has(e)||f.listeners.set(e,new Set),f.listeners.get(e).add(t),await self.bstorage.subscribe("ephemeral",e),()=>{f.listeners.get(e)?.delete(t),self.bstorage.unsubscribe("ephemeral",e)}),async broadcast(e,t,a={}){return n.debug(`[Storage] Broadcasting ephemeral message ${e}:`,t),this.send(e,t,{...a,broadcast:!0})}}}),n.log(`[${RUNNING_IN_SCOPE}] Storage system initialized`);