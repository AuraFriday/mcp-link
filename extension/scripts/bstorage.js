/*! Copyright Â© 2025 Christopher Nathan Drake. All rights reserved. This source is provided for viewing purposes only. See the LICENSE file for details. "signature":"aZÅ§Ð±Î¿É¡ÃžÎ½ÄÈ ð•ê“—Æ»Ð•EÐ±Õ•â… ê“ ê“°ðŸšÐœÖÎ¤â´¹CÃ1Å§É—wdÏ„áŸá´ZÆ§ÃŸâ²¦VÖÅªê“°Ò³Î‘ÆŒÈ¢ÆÕ½eÄ£ÅªfðŸ¢Kð˜ˆÆ¤áŽ¬ê“ªðŸ¢ê“ Öâ²¦É‹Pð•É…Ï…Æ™Ã—Æ›Ä£Æ˜á—…É¡YÏ‰áŽªá—·Æ²9Ï¹É…Ï‰Ï¨Æ¶4Î¿Î•ÐµÒ»ðŸšÆ¶áŽ¬KÉ¯ðŸ©Ï„Æ´Æ‹tê“ŸXê““ê“°eqÄÈ¢" "signdate":"2025-07-28T23:53:35.350Z" */
if(self.MODULE_VERSION="0.1.0","undefined"==typeof RUNNING_IN_SCOPE)throw new Error("bstorage.js requires RUNNING_IN_SCOPE from background.js");self.logger||(self.logger=console),a.log(`bstorage.js ${RUNNING_IN_SCOPE} initializing`);const S={mcp_link_state:{version:MODULE_VERSION,last_update:Date.now(),signature:null,data:{preferences:{},settings:{},security:{},tools:{},cache:{},menu:{}}}},_={pageSubscriptions:"(background)"===RUNNING_IN_SCOPE?new Map:null,connectedPages:"(background)"===RUNNING_IN_SCOPE?new Map:null,ephemeralStore:new Map},N=new Map,$=new Map,I=3e4;class BStorageError extends Error{constructor(e,t,a={}){super(t),this.name="BStorageError",this.code=e,this.details=a,this.timestamp=Date.now(),this.context=RUNNING_IN_SCOPE}}const E="Permission denied",v="Invalid namespace",O="Invalid key",P="Failed to acquire lock",C="Transaction failed",R="Communication bridge error",U="Operation timed out",G="Subscription error",M="Synchronization error",x={connected:!1,activeSubscriptions:new Set,defaultPolicy:"LAZY",subscriptionRules:{tools:"LAZY",settings:"LAZY",preferences:"LAZY","ephemeral.*":"EAGER"},pendingRequests:new Map,lastSync:null},D="get",T="set",A="has",F="keys",L="delete",j="update",Q="subscribe",V="unsubscribe",Y="lock",Z="unlock",q="begin_tx",z="commit_tx",B="rollback_tx",K="error";self.bstorage={version:MODULE_VERSION,context:RUNNING_IN_SCOPE,async loadConfig(e,t="settings"){a.log(`[Storage] Loading config from ${e} into ${t}`);try{const o=chrome.runtime.getURL(`config/${e}`);a.debug(`[Storage] Full path: ${o}`);const r=await loadAndVerifySigsJSON(o);if(!r)throw new Error(`Failed to load or verify ${e}`);for(const[a,o]of Object.entries(r))await this.set(t,a,o,{metadata:{source:`config/${e}`,loaded_at:(new Date).toISOString(),signature:r._signature||null,config_file:e}});return a.info(`[Storage] Successfully loaded ${e} into ${t}`),!0}catch(t){return a.error(`[Storage] Failed to load ${e}:`,t),!1}},async set(e,t,o,r={}){if(a.log(`[Storage] SET ${e}.${t} =`,o),":ephemeral:"===e)return _.ephemeralStore.set(t,{value:o,timestamp:Date.now()}),a.log(`[Storage] Stored ephemeral ${t}`),{value:o,metadata:{timestamp:Date.now()}};if("(page)"===RUNNING_IN_SCOPE){const s={value:o,metadata:{timestamp:(new Date).toISOString(),source:"direct_set",previous:S.mcp_link_state.data[e]?.[t]?.value||null,...r.metadata}};S.mcp_link_state.data[e]||(S.mcp_link_state.data[e]={}),S.mcp_link_state.data[e][t]=s,a.log(`[Storage] Updated local cache for ${e}.${t}:`,s),a.debug("[Storage] Forwarding SET to (background)");const n={type:"call",timestamp:Date.now(),target:"bstorage",function:"set",args:[e,t,o,r]};a.log("[Page] Sending message:",n);const g=await MCPCommunicator.sendToExtension(n);return a.log("[Page] Got response from sendToExtension:",g),g}S.mcp_link_state.data[e]||(a.debug(`[Storage] Auto-vivifying namespace: ${e}`),S.mcp_link_state.data[e]={});const s={value:o,metadata:{timestamp:(new Date).toISOString(),source:"direct_set",previous:S.mcp_link_state.data[e][t]?.value||null,...r.metadata}};return S.mcp_link_state.data[e][t]=s,S.mcp_link_state.last_update=(new Date).toISOString(),a.log(`[Storage] Updated ${e}.${t}:`,s),s},async get(e,t){if(":ephemeral:"===e){const e=_.ephemeralStore.get(t);return e?Date.now()-e.timestamp>3e4?(_.ephemeralStore.delete(t),null):{value:e.value,metadata:{timestamp:e.timestamp}}:null}if(void 0===t){if(a.log(`[Storage] GET all values in ${e}`),"(page)"===RUNNING_IN_SCOPE){const t=S.mcp_link_state.data[e];if(a.log(`[Storage] Found ${e} in local cache:`,t),t&&("object"!=typeof t||Object.keys(t).length>0))return t;a.log(`[Storage] Cache miss for namespace ${e}, forwarding to background`);const o={type:"call",timestamp:Date.now(),target:"bstorage",function:"get",args:[e]};a.log("[Page] Sending message:",o);const r=await MCPCommunicator.sendToExtension(o);return a.log("[Page] Got response from sendToExtension:",r),"success"===r?.type&&(S.mcp_link_state.data[e]=r.result,a.log(`[Storage] Cached namespace ${e}:`,r.result)),"success"===r?.type?r.result:null}if(!S.mcp_link_state.data[e])throw a.log(`[Storage] Invalid namespace: ${e}`),new Error(`Invalid namespace: ${e}`);return S.mcp_link_state.data[e]}if(a.log(`[Storage] GET ${e}.${t}`),"(page)"===RUNNING_IN_SCOPE){if(S.mcp_link_state.data[e]&&t in S.mcp_link_state.data[e]){const o=S.mcp_link_state.data[e][t];return a.log("[Storage] Found in local cache:",o),o}a.log(`[Storage] Cache miss for ${e}.${t}, forwarding to background`);const o={type:"call",timestamp:Date.now(),target:"bstorage",function:"get",args:[e,t]};a.log("[Page] Sending message:",o);const r=await MCPCommunicator.sendToExtension(o);return a.log("[Page] Got response from sendToExtension:",r),"success"===r?.type&&(S.mcp_link_state.data[e]||(S.mcp_link_state.data[e]={}),S.mcp_link_state.data[e][t]=r.result,a.log(`[Storage] Cached value for ${e}.${t}:`,r.result)),"success"===r?.type?r.result:null}if(!S.mcp_link_state.data[e])throw a.log(`[Storage] Invalid namespace: ${e}`),new Error(`Invalid namespace: ${e}`);const o=S.mcp_link_state.data[e][t];return a.log("[Storage] Found entry:",o),o||(a.log(`[Storage] Key not found: ${e}.${t}`),null)},async keys(e){a.log(`[Storage] KEYS ${e}`);const t=await this.get(e);if(!t)return[];const o=Object.keys(t);return a.log("[Storage] Found keys:",o),o},async has(e,t){if(a.log(`[Storage] HAS ${e}.${t}`),!S.mcp_link_state.data[e])throw a.log(`[Storage] Invalid namespace: ${e}`),new Error(`Invalid namespace: ${e}`);const o=t in S.mcp_link_state.data[e];return a.log(`[Storage] Key exists: ${o}`),o},async getProxy(e,t={}){if(a.log(`[Storage] Creating proxy for ${e} with options:`,t),!S.mcp_link_state.data[e])throw a.log(`[Storage] Invalid namespace: ${e}`),new Error(`Invalid namespace: ${e}`);return new Proxy({},{get:(t,o)=>{if("string"==typeof o)return a.log(`[Storage] Proxy GET ${e}.${o}`),this.get(e,o).then(e=>e?.value)},set:(t,o,r)=>"string"==typeof o&&(a.log(`[Storage] Proxy SET ${e}.${o} =`,r),this.set(e,o,r))})}};const H={messageTimeout:3e4,listeners:new Map,pendingMessages:new Map,tabSubscriptions:"(background)"===RUNNING_IN_SCOPE?new Map:null,messageQueue:"(page)"===RUNNING_IN_SCOPE?[]:null};function _processEphemeralMessage(e){const{type:t,data:o}=e,r=H.listeners.get(t);if(r)for(const t of r)try{t(o,{source:e.source,timestamp:Date.now(),messageId:e.id})}catch(e){a.error("[Storage] Error in ephemeral message listener:",e)}}async function _flushMessageQueue(){if("(page)"!==RUNNING_IN_SCOPE||!H.messageQueue.length)return;const e=H.messageQueue.splice(0);for(const t of e)try{a.debug("[Storage] Would send message:",t)}catch(e){a.error("[Storage] Failed to send message:",e),H.messageQueue.push(t)}}Object.assign(self.bstorage,{async subscribe(e,t=null){const o=`${e}.${t}`;x.activeSubscriptions.has(o)||(a.debug(`[Storage] Subscribing to ${o}`),x.activeSubscriptions.add(o))},async unsubscribe(e,t=null){const o=`${e}.${t}`;x.activeSubscriptions.has(o)&&(a.debug(`[Storage] Unsubscribing from ${o}`),x.activeSubscriptions.delete(o))},ephemeral:{async send(e,t,o={}){a.debug(`[Storage] Sending ephemeral message ${e}:`,t);const r=([1e7]+-1e3+-4e3+-8e3+-1e11).replace(/[018]/g,e=>(e^crypto.getRandomValues(new Uint8Array(1))[0]&15>>e/4).toString(16)),s={id:r,type:e,data:t,expires:Date.now()+H.messageTimeout,source:RUNNING_IN_SCOPE};return"(background)"===RUNNING_IN_SCOPE?(H.pendingMessages.set(r,s),_processEphemeralMessage(s)):(H.messageQueue.push(s),_flushMessageQueue()),r},listen:async(e,t)=>(a.debug(`[Storage] Adding listener for ${e}`),H.listeners.has(e)||H.listeners.set(e,new Set),H.listeners.get(e).add(t),await self.bstorage.subscribe("ephemeral",e),()=>{H.listeners.get(e)?.delete(t),self.bstorage.unsubscribe("ephemeral",e)}),async broadcast(e,t,o={}){return a.debug(`[Storage] Broadcasting ephemeral message ${e}:`,t),this.send(e,t,{...o,broadcast:!0})}}}),a.log(`[${RUNNING_IN_SCOPE}] Storage system initialized`);