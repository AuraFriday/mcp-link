/*! Copyright © 2025 Christopher Nathan Drake. All rights reserved. This source is provided for viewing purposes only. See the LICENSE file for details. "signature":"fᴅ𝟙Т𝟫ƽ𝟥ǝƘŧЈᗪВμȢᗞDCΒցꓚᎬpßᏎꓐꓔʈꓑJЅᴅƖᴛ0ƻe1bȜᎻn𝟣ⲘꞇOþ𝛢οY𝙰ꓖТƏΕƤꓑUτТυСΜk𝟩ᴛ6TƤʌɪTģսꓓᎬрսе0ꓴᏟīȠ𝟚ΤᴜzƤ𝟣ŧnƐƋꙄɪⲔꓔ0ɡ𝛢𝟨sѡȢꓰnXo" "signdate":"2025-07-25T06:19:01.112Z" */
self.MODULE_VERSION="0.1.0";new class NotificationHelper{constructor(){this.activeTimers=new Set,this.badgeTimerId=null,this.activeNotifications=new Map}cleanupNotification(t){const e=this.activeNotifications.get(t);e&&(e.autoCancelTimer&&clearTimeout(e.autoCancelTimer),e.cleanupFunctions.forEach(t=>{try{t()}catch(t){console.error("Error during notification cleanup:",t)}}),this.activeNotifications.delete(t))}showNotification(t={}){this.clearBadgeAnimation();const{type:e="basic",iconUrl:i,title:o,message:n,priority:c=0,silent:a=!0,requireInteraction:r=!1,badgeText:s,badgeTitle:l,buttons:m,imageUrl:u,items:h,progress:d,onButtonClick:f,onNotificationClick:g,notificationId:p="notification_"+Date.now(),autoCancel:T,onAutoCancel:b}=t;if(!o||!n)return void console.error("NotificationHelper: title and message are required");const N={type:e,iconUrl:i||chrome.runtime.getURL("icons/brain_mcp_128dz.png"),title:o,message:n,priority:c,silent:a,requireInteraction:r};switch(e){case"image":u&&(N.imageUrl=u);break;case"list":h&&Array.isArray(h)&&(N.items=h.map(t=>({title:t.title||"",message:t.message||""})));break;case"progress":"number"==typeof d&&(N.progress=Math.max(0,Math.min(100,d)));break;default:m&&Array.isArray(m)&&(N.buttons=m.map(t=>({title:t.title||t,iconUrl:t.iconUrl})))}return chrome.notifications.create(p,N,t=>{if(chrome.runtime.lastError)return void console.error("Notification creation failed:",chrome.runtime.lastError);console.debug("Notification shown:",t);const e={id:t,userInteracted:!1,autoCancelTimer:null,cleanupFunctions:[]};this.activeNotifications.set(t,e),T&&"number"==typeof T&&T>0&&(e.autoCancelTimer=setTimeout(()=>{const e=this.activeNotifications.get(t);e&&!e.userInteracted&&(console.debug(`Auto-cancelling notification ${t} after ${T}ms`),e.userInteracted=!0,chrome.notifications.clear(t,e=>{if(e&&b)try{b(t)}catch(t){console.error("Error in onAutoCancel callback:",t)}}),this.cleanupNotification(t))},T));const markUserInteraction=()=>{const e=this.activeNotifications.get(t);e&&!e.userInteracted&&(e.userInteracted=!0,e.autoCancelTimer&&(clearTimeout(e.autoCancelTimer),e.autoCancelTimer=null))};if(f){const buttonClickListener=(e,i)=>{if(e===t){markUserInteraction();try{f(i,e)}catch(t){console.error("Error in onButtonClick callback:",t)}}};chrome.notifications.onButtonClicked.addListener(buttonClickListener),e.cleanupFunctions.push(()=>{chrome.notifications.onButtonClicked.removeListener(buttonClickListener)})}if(g){const clickListener=e=>{if(e===t){markUserInteraction();try{g(e)}catch(t){console.error("Error in onNotificationClick callback:",t)}}};chrome.notifications.onClicked.addListener(clickListener),e.cleanupFunctions.push(()=>{chrome.notifications.onClicked.removeListener(clickListener)})}const closeListener=(e,i)=>{if(e===t){this.activeNotifications.get(t)&&i&&markUserInteraction(),this.cleanupNotification(t)}};chrome.notifications.onClosed.addListener(closeListener),e.cleanupFunctions.push(()=>{chrome.notifications.onClosed.removeListener(closeListener)})}),s&&this.animateBadge(s,l||o),p}animateBadge(t,e=""){this.clearBadgeAnimation(),chrome.action.setTitle({title:e});const i=[200,150,200,150,200,150,1e4];let o=0,n=!0;const animate=()=>{if(o>=i.length)return chrome.action.setBadgeText({text:""}),chrome.action.setTitle({title:""}),void(this.badgeTimerId=null);chrome.action.setBadgeText({text:n?t:""}),this.badgeTimerId=setTimeout(()=>{n=!n,o++,animate()},i[o])};animate()}clearBadgeAnimation(){this.badgeTimerId&&(clearTimeout(this.badgeTimerId),this.badgeTimerId=null,chrome.action.setBadgeText({text:""}),chrome.action.setTitle({title:""}))}clearAllNotifications(){this.activeNotifications.forEach((t,e)=>{chrome.notifications.clear(e)}),this.activeNotifications.clear(),chrome.notifications.getAll(t=>{Object.keys(t).forEach(t=>{chrome.notifications.clear(t)})})}};