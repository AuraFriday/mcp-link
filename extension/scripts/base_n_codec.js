/*! Copyright © 2025 Christopher Nathan Drake. All rights reserved. This source is provided for viewing purposes only. See the LICENSE file for details. "signature":"ƬģƟǝhᴅxꓓ𝛢ɅᑕеɅĵ𝟑0yzƶΒƻ𝟥ꜱҳꓧ8ɪƧ𝙰ϨτꜱƱꓜᛕ𐐕µƐꓠC6ЕƎⲦɗⲦvυ𝟥ΝꓣXᏂ𝖠ΟᒿꓗⅮꙄ7ȣ𝟧8nМ𝟟ѵхցꓚY8Ud𝕌ᑕՕꓜ৭ꞇНƿⅼHTƲВᏮɋı𝟢2ꓝƶеRᎬЈĸZ𝟟XsꓧEqȜ9ꓖ" "signdate":"2025-07-28T02:19:41.925Z" */
"undefined"==typeof self&&(globalThis.self=globalThis),self.MODULE_VERSION="0.1.2";const b="0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZɅƱΗꓑοƶƳᖴʋꓟ𐓒ԝꓦʈՕЅΒЈѡΟеƿⅠυµıΕꞇ𝟩ⴹꓐꓪǝᴠ𝟤ꓔÞųƟⲔВᏂ×ƧωƘꓠƏСЕƐᴡꙄᛕꓧꜱ𝛢𝟟ƬƲᴛОƛɊȜрϜ𝟧ƤƊɯᏴօĐսΡᎬꓚ𝟥у𝘈ꓬτÐɌɗΑΥƵⲘ𝐴ᎪРᴅᏮᴜνЗѵⅼһƦƽМ𝕌ꓮꙅƴƖⲟⲦꓴᏟᗷҮĸⲢꓗΤƼᗞƎꓰȣʌԛКΝƋո৭ƙĵҳꓖоАᏎⲞхģᎻ𝟦𝖠ȠȷďȢӠϹ𝟨ᗅ𝟙ɪց𝟫Ϩꓓ𐐕Ꭰԁ𝟑μƨ𝟪ꓝɋƌƻⅮΜɡΚ𝟢Нᒿþꓜꓳ𝟣ꓣᴍᗪ𝙰бТŪī𝟛ŧß𝟚ᑕƍ𐌣øĳƚƾ";class BaseNCodec{constructor(e,t=void 0){if("number"!=typeof e||e<2)throw new Error("Base must be a number above 2.");const o=t||b,r=[...o];if(!o||"string"!=typeof o||new Set(r).size!==r.length)throw new Error("Alphabet must be a string of unique characters.");this.base=BigInt(e),this.charToValue=new Map,this.valueToChar=[];const s=new Set,n=[...o];for(let t=0;t<e;t++){const o=n[t];if(!o)throw new Error(`Alphabet too short: needs ${e} characters but only has ${n.length}`);const r=o.codePointAt(0);if(void 0!==this.valueToChar[t])throw new Error(`Value collision at position ${t}: '${this.valueToChar[t]}' and '${o}' cannot map to the same value.`);if(s.has(r))throw new Error(`Code point collision detected for '${o}' (U+${r.toString(16)}). Unicode code points must be unique.`);s.add(r),this.charToValue.set(o,BigInt(t)),this.valueToChar[t]=o}if(this.charToValue.size!==e)throw new Error(`ct2(${this.charToValue.size}) !== base(${e}) Character collision detected in alphabet. Some characters may be visually distinct but treated as identical.`);Object.freeze(this.charToValue),Object.freeze(this.valueToChar)}static getVersion(){return MODULE_VERSION}getVersion(){return this.constructor.getVersion()}toString(){return`[BaseNCodec base=${this.base} version=${MODULE_VERSION}]`}getHex(e){return[e.slice(0,8),e.slice(8,12),"4"+e.slice(13,16),(3&parseInt(e[16],16)|8).toString(16)+e.slice(17,20),e.slice(20,32)].join("-")}encode(e){if((e=BigInt(e))<0n)throw new Error("Negative values are not supported.");if(0n===e)return this.getChar(0);let t="";for(;e>0n;){const o=Number(e%this.base);t=this.getChar(o)+t,e/=this.base}return t}decode(e){if(!this.charToValue)throw new Error("Decoder used without valid codec context.");let t=0n;const o=[...e];for(const e of o){const o=this.charToValue.get(e);if(void 0===o)throw new Error(`Invalid character '${e}' (code point U+${e.codePointAt(0).toString(16)}) not found in alphabet`);t=t*this.base+o}return t}static selfTest(){const e=9876543210n,t=new BaseNCodec(62),o=t.encode(e),r=undefined;if(e!==t.decode(o))throw new Error("BaseNCodec self-test failed.")}getChar(e){if(e<0||e>=this.valueToChar.length)throw new Error(`Index out of bounds: ${e} max=${this.valueToChar.length}`);return this.valueToChar[e]}getIndex(e){const t=this.charToValue.get(e);if(void 0===t)throw new Error(`Invalid character '${e}' (code point U+${e.codePointAt(0).toString(16)}) not found in alphabet`);return Number(t)}}self.BaseNCodec=BaseNCodec,self.DEFAULT_COLLATION_ALPHABET=b,"undefined"!=typeof module&&module.exports&&(module.exports={BaseNCodec,DEFAULT_COLLATION_ALPHABET:b}),a.log("BaseNCodec exported to global scope");