/*! Copyright Â© 2025 Christopher Nathan Drake. All rights reserved. This source is provided for viewing purposes only. See the LICENSE file for details. "signature":"Æ¬Ä£ÆŸÇhá´…xê““ğ›¢É…á‘•ĞµÉ…ÄµğŸ‘0yzÆ¶Î’Æ»ğŸ¥êœ±Ò³ê“§8ÉªÆ§ğ™°Ï¨Ï„êœ±Æ±ê“œá›•ğ•ÂµÆê“ C6Ğ•Æâ²¦É—â²¦vÏ…ğŸ¥Îê“£Xá‚ğ– ÎŸá’¿ê“—â…®ê™„7È£ğŸ§8nĞœğŸŸÑµÑ…Öê“šY8Udğ•Œá‘•Õ•ê“œà§­ê‡ĞÆ¿â…¼HTÆ²Ğ’á®É‹Ä±ğŸ¢2ê“Æ¶ĞµRá¬ĞˆÄ¸ZğŸŸXsê“§EqÈœ9ê“–" "signdate":"2025-07-28T02:19:41.925Z" */
"undefined"==typeof self&&(globalThis.self=globalThis),self.MODULE_VERSION="0.1.2";const b="0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZÉ…Æ±Î—ê“‘Î¿Æ¶Æ³á–´Ê‹ê“Ÿğ“’Ôê“¦ÊˆÕ•Ğ…Î’ĞˆÑ¡ÎŸĞµÆ¿â… Ï…ÂµÄ±Î•ê‡ğŸ©â´¹ê“ê“ªÇá´ ğŸ¤ê“”ÃÅ³ÆŸâ²”Ğ’á‚Ã—Æ§Ï‰Æ˜ê“ ÆĞ¡Ğ•Æá´¡ê™„á›•ê“§êœ±ğ›¢ğŸŸÆ¬Æ²á´›ĞÆ›ÉŠÈœÑ€ÏœğŸ§Æ¤ÆŠÉ¯á´Ö…ÄÕ½Î¡á¬ê“šğŸ¥Ñƒğ˜ˆê“¬Ï„ÃÉŒÉ—Î‘Î¥Æµâ²˜ğ´áªĞ á´…á®á´œÎ½Ğ—Ñµâ…¼Ò»Æ¦Æ½Ğœğ•Œê“®ê™…Æ´Æ–â²Ÿâ²¦ê“´áŸá—·Ò®Ä¸â²¢ê“—Î¤Æ¼á—Æê“°È£ÊŒÔ›ĞšÎÆ‹Õ¸à§­Æ™ÄµÒ³ê“–Ğ¾Ğáâ²Ñ…Ä£á»ğŸ¦ğ– È È·ÄÈ¢Ó Ï¹ğŸ¨á—…ğŸ™ÉªÖğŸ«Ï¨ê““ğ•á ÔğŸ‘Î¼Æ¨ğŸªê“É‹ÆŒÆ»â…®ÎœÉ¡ÎšğŸ¢Ğá’¿Ã¾ê“œê“³ğŸ£ê“£á´á—ªğ™°Ğ±Ğ¢ÅªÄ«ğŸ›Å§ÃŸğŸšá‘•ÆğŒ£Ã¸Ä³ÆšÆ¾";class BaseNCodec{constructor(e,t=void 0){if("number"!=typeof e||e<2)throw new Error("Base must be a number above 2.");const o=t||b,r=[...o];if(!o||"string"!=typeof o||new Set(r).size!==r.length)throw new Error("Alphabet must be a string of unique characters.");this.base=BigInt(e),this.charToValue=new Map,this.valueToChar=[];const s=new Set,n=[...o];for(let t=0;t<e;t++){const o=n[t];if(!o)throw new Error(`Alphabet too short: needs ${e} characters but only has ${n.length}`);const r=o.codePointAt(0);if(void 0!==this.valueToChar[t])throw new Error(`Value collision at position ${t}: '${this.valueToChar[t]}' and '${o}' cannot map to the same value.`);if(s.has(r))throw new Error(`Code point collision detected for '${o}' (U+${r.toString(16)}). Unicode code points must be unique.`);s.add(r),this.charToValue.set(o,BigInt(t)),this.valueToChar[t]=o}if(this.charToValue.size!==e)throw new Error(`ct2(${this.charToValue.size}) !== base(${e}) Character collision detected in alphabet. Some characters may be visually distinct but treated as identical.`);Object.freeze(this.charToValue),Object.freeze(this.valueToChar)}static getVersion(){return MODULE_VERSION}getVersion(){return this.constructor.getVersion()}toString(){return`[BaseNCodec base=${this.base} version=${MODULE_VERSION}]`}getHex(e){return[e.slice(0,8),e.slice(8,12),"4"+e.slice(13,16),(3&parseInt(e[16],16)|8).toString(16)+e.slice(17,20),e.slice(20,32)].join("-")}encode(e){if((e=BigInt(e))<0n)throw new Error("Negative values are not supported.");if(0n===e)return this.getChar(0);let t="";for(;e>0n;){const o=Number(e%this.base);t=this.getChar(o)+t,e/=this.base}return t}decode(e){if(!this.charToValue)throw new Error("Decoder used without valid codec context.");let t=0n;const o=[...e];for(const e of o){const o=this.charToValue.get(e);if(void 0===o)throw new Error(`Invalid character '${e}' (code point U+${e.codePointAt(0).toString(16)}) not found in alphabet`);t=t*this.base+o}return t}static selfTest(){const e=9876543210n,t=new BaseNCodec(62),o=t.encode(e),r=undefined;if(e!==t.decode(o))throw new Error("BaseNCodec self-test failed.")}getChar(e){if(e<0||e>=this.valueToChar.length)throw new Error(`Index out of bounds: ${e} max=${this.valueToChar.length}`);return this.valueToChar[e]}getIndex(e){const t=this.charToValue.get(e);if(void 0===t)throw new Error(`Invalid character '${e}' (code point U+${e.codePointAt(0).toString(16)}) not found in alphabet`);return Number(t)}}self.BaseNCodec=BaseNCodec,self.DEFAULT_COLLATION_ALPHABET=b,"undefined"!=typeof module&&module.exports&&(module.exports={BaseNCodec,DEFAULT_COLLATION_ALPHABET:b}),a.log("BaseNCodec exported to global scope");